<!DOCTYPE html>
<html  lang="zh">

<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />

<meta name="generator" content="Hexo 4.2.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>《结构型设计模式》之iOS系统框架实践 - 轻墨</title>


    <meta name="description" content="结构型设计模式是从程序的结构上解决模块之间的耦合问题，主要包括适配器模式、桥接模式、组合模式、装饰器模式、外观模式、享元模式和代理模式等7种经典设计模式，在iOS系统框架中组合模式、装饰器模式和享元模式是有经典实现的，而适配器模式、桥接模式、外观模式和代理模式iOS系统框架中的实现并不明显，但在第三方框架或者贝聊（我所在的公司）的App是有用到的，为便于讲解，本文会挑选最恰当的例子。 本文是设计模">
<meta property="og:type" content="article">
<meta property="og:title" content="《结构型设计模式》之iOS系统框架实践">
<meta property="og:url" content="http://yoursite.com/2017/03/18/structuralpattern/index.html">
<meta property="og:site_name" content="轻墨">
<meta property="og:description" content="结构型设计模式是从程序的结构上解决模块之间的耦合问题，主要包括适配器模式、桥接模式、组合模式、装饰器模式、外观模式、享元模式和代理模式等7种经典设计模式，在iOS系统框架中组合模式、装饰器模式和享元模式是有经典实现的，而适配器模式、桥接模式、外观模式和代理模式iOS系统框架中的实现并不明显，但在第三方框架或者贝聊（我所在的公司）的App是有用到的，为便于讲解，本文会挑选最恰当的例子。 本文是设计模">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/images/designpattern.jpg">
<meta property="article:published_time" content="2017-03-18T12:47:10.000Z">
<meta property="article:modified_time" content="2020-02-10T15:33:11.179Z">
<meta property="article:author" content="轻墨">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="design pattern">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/designpattern.jpg">







<link rel="icon" href="/../images/logo.png">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
<style>body>.footer,body>.navbar,body>.section{opacity:0}</style>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/back-to-top.css">

    
    
    
    
    
    
    
    <link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
    
    
    


<link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body class="is-2-column">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/../images/logo.png" alt="《结构型设计模式》之iOS系统框架实践" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/.">首页</a>
                
                <a class="navbar-item"
                href="/archives">归档</a>
                
                <a class="navbar-item"
                href="/tags">标签</a>
                
                <a class="navbar-item"
                href="/about">关于</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    <a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/shellhue">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-9-tablet is-9-desktop is-9-widescreen has-order-2 column-main">
<div class="card">
    
    <div class="card-image">
        <span  class="image is-7by1">
            <img class="thumbnail" src="/images/designpattern.jpg" alt="《结构型设计模式》之iOS系统框架实践">
        </span>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-03-18T12:47:10.000Z">2017-03-18</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    25 分钟 读完 (大约 3776 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                《结构型设计模式》之iOS系统框架实践
            
        </h1>
        <div class="content">
            <p>结构型设计模式是从程序的结构上解决模块之间的耦合问题，主要包括适配器模式、桥接模式、组合模式、装饰器模式、外观模式、享元模式和代理模式等7种经典设计模式，在iOS系统框架中组合模式、装饰器模式和享元模式是有经典实现的，而适配器模式、桥接模式、外观模式和代理模式iOS系统框架中的实现并不明显，但在第三方框架或者贝聊（我所在的公司）的App是有用到的，为便于讲解，本文会挑选最恰当的例子。</p>
<p>本文是设计模式之iOS系统框架实践系列中的第二篇（总共三篇），如果您对《创建型设计模式》感兴趣，建议看看我的前一篇文章<a href="http://shellhue.github.io/2017/03/11/creationalDesignPattern/">《创建型设计模式》之iOS系统框架实践</a>。</p>
<h2 id="适配器模式（Adapter）"><a href="#适配器模式（Adapter）" class="headerlink" title="适配器模式（Adapter）"></a>适配器模式（Adapter）</h2><p>适配器模式是将一种接口，转换成另外一种接口，一般被适配的类的功能与外界所希望的一致，只是接口与外界所希望的不同，所以需要适配接口。一般需要新旧接口的转换时用到。<br><a id="more"></a><br>不少<a href="https://www.raywenderlich.com/46988/ios-design-patterns">资料</a>上讲iOS中的delegate委托就是一种适配器模式，个人觉得太牵强。虽然将一个现有的类，扩展遵循指定delegate的协议，实现了接口的改变，但功能完全是新添加的，何来接口转换只说？（原来<a href="https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/CocoaDesignPatterns/CocoaDesignPatterns.html#//apple_ref/doc/uid/TP40002974-CH6-SW6">苹果官方资料</a>说protocol就是适配器模式，也是醉了）</p>
<p>由于暂未发现iOS系统框架中特别典型的适配器模式，本文就以贝聊App中的IM（instant message即时通讯）项目为例。</p>
<p>贝聊IM用的是阿里百川云望（下文简称云望）服务器，UI自己实现。对于每一条消息，云望都有自己的消息类型YWMessage（云望SDK中定义的一个协议），大体协议结构如下：<br><pre><code class="hljs swift"><span class="hljs-keyword">import</span> UIKit
<span class="hljs-comment">// 消息体实体类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YWMessageBody</span> </span>&#123;
  
&#125;

<span class="hljs-comment">// 消息协议</span>
<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">YWMessage</span> </span>&#123;
  <span class="hljs-keyword">var</span> messageId: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;
  <span class="hljs-keyword">var</span> fromPersonId: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;
  <span class="hljs-keyword">var</span> toPersonId: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;
  <span class="hljs-keyword">var</span> createDate: <span class="hljs-type">TimeInterval</span> &#123; <span class="hljs-keyword">get</span> &#125;
  <span class="hljs-keyword">var</span> conversationId: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;
  <span class="hljs-keyword">var</span> messageBody: <span class="hljs-type">YWMessageBody</span> &#123; <span class="hljs-keyword">get</span> &#125;
&#125;</code></pre><br>为解除第三方SDK与贝聊App内部聊天UI过渡耦合，需要将云望消息类型转换成贝聊自己的消息类型，也是个协议，贝聊消息协议定义如下：<br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">MessageBody</span> </span>&#123;
  
&#125;

<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Message</span> </span>&#123;
  <span class="hljs-keyword">var</span> messageID: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;
  <span class="hljs-keyword">var</span> senderID: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;
  <span class="hljs-keyword">var</span> receiverID: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;
  <span class="hljs-keyword">var</span> createTimeInterval: <span class="hljs-type">TimeInterval</span> &#123; <span class="hljs-keyword">get</span> &#125;
  <span class="hljs-keyword">var</span> conversationID: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;
  <span class="hljs-keyword">var</span> messageBody: <span class="hljs-type">MessageBody</span> &#123; <span class="hljs-keyword">get</span> &#125;
  
&#125;</code></pre><br>云望消息类型YWMessage和贝聊消息类型Message接口功能基本一致，只是接口定义不一致，这就需要接口的适配。<br>虽然云望SDK消息类型公开的接口是个YWMessage协议，但当有消息发送过来时，所收到的是一个实现了YWMessage协议的具体私有类，YWMessageConcrete，为实现接口转换，定义一个做消息转换的适配器消息类MessageAdaperForYWMessage：<br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageAdaperForYWMessage</span>: <span class="hljs-title">Message</span> </span>&#123;
  <span class="hljs-keyword">let</span> ywMessage: <span class="hljs-type">YWMessage</span>
  <span class="hljs-keyword">init</span>(ywMessage: <span class="hljs-type">YWMessage</span>) &#123;
    <span class="hljs-keyword">self</span>.ywMessage = ywMessage
  &#125;
  <span class="hljs-keyword">var</span> messageID: <span class="hljs-type">String</span> &#123;
    <span class="hljs-keyword">return</span> ywMessage.messageId
  &#125;
  <span class="hljs-keyword">var</span> senderID: <span class="hljs-type">String</span> &#123;
    <span class="hljs-keyword">return</span> ywMessage.fromPersonId
  &#125;
  <span class="hljs-keyword">var</span> receiverID: <span class="hljs-type">String</span> &#123;
    <span class="hljs-keyword">return</span> ywMessage.toPersonId
  &#125;
  <span class="hljs-keyword">var</span> createTimeInterval: <span class="hljs-type">TimeInterval</span> &#123;
    <span class="hljs-keyword">return</span> ywMessage.createDate
  &#125;
  <span class="hljs-keyword">var</span> conversationID: <span class="hljs-type">String</span> &#123;
    <span class="hljs-keyword">return</span> ywMessage.conversationId
  &#125;
  <span class="hljs-keyword">var</span> messageBody: <span class="hljs-type">MessageBody</span> &#123;
    <span class="hljs-keyword">return</span> ywMessage.messageBody
  &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">YWMessageBody</span>: <span class="hljs-title">MessageBody</span> </span>&#123;
  
&#125;</code></pre></p>
<h2 id="组合模式（Composite）"><a href="#组合模式（Composite）" class="headerlink" title="组合模式（Composite）"></a>组合模式（Composite）</h2><p>组合模式就是将对象组合成树形结构，以表示“部分-整体”的层次结构，而且单个对象和组合对象的接口一致，如果从整个树形结构中截取任何一部分，client不知是单个对象，还是组合对象。对应的类图如下：</p>
<p><img src="/images/compositeclassdiagram.gif" alt=""></p>
<p>容器类（Composite）和叶子类（Leaf)其实都是实现Component接口的子类，client在使用时不做区分，都当作Component使用。容器类可以添加容器或者叶子做子类，而叶子类不能添加任何子类。所形成的树形结构如下：<br><img src="/images/compositetree.png" alt=""></p>
<p>在UIKit中，我们熟悉的不能再熟悉的UIView和CALayer是经典的组合模式，并且UIView和CALayer并没有区分容器类和叶子类，而是统一只有一个单一容器类UIView和CALayer。其实这样使用起来更加亲民，不用区分是容器还是叶子。</p>
<p>UIView的实现起来是相当简单的（为不与系统UIView混淆，这里取View），如下：<br><pre><code class="hljs swift"><span class="hljs-keyword">import</span> UIKit

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">View</span>: <span class="hljs-title">Equatable</span> </span>&#123;
  <span class="hljs-keyword">var</span> subviews: [<span class="hljs-type">View</span>] = []
  <span class="hljs-keyword">var</span> superView: <span class="hljs-type">View?</span>

  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addSubview</span><span class="hljs-params">(subview: View)</span></span> &#123;
    subviews.append(subview)
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeSubview</span><span class="hljs-params">(subview: View)</span></span> &#123;
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> index = subviews.index(of: subview) &#123;
      subviews.remove(at: index)
    &#125;
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-number">_</span> rect: CGRect)</span></span> &#123;
    <span class="hljs-comment">// 具体的绘制图形的代码</span>
  &#125;
&#125;

<span class="hljs-comment">// Array.index(of:)必须遵循Equatable协议</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> == <span class="hljs-params">(lhs: View, rhs: View)</span></span> -&gt; <span class="hljs-type">Bool</span> &#123;
  <span class="hljs-keyword">return</span> lhs === rhs
&#125;</code></pre><br>具体使用时，先创建各个View，然后根据需要添加层级关系如下：<br><pre><code class="hljs swift"><span class="hljs-keyword">let</span> view1 = <span class="hljs-type">View</span>()
<span class="hljs-keyword">let</span> view2 = <span class="hljs-type">View</span>()
<span class="hljs-keyword">let</span> view3 = <span class="hljs-type">View</span>()
<span class="hljs-keyword">let</span> view4 = <span class="hljs-type">View</span>()
<span class="hljs-keyword">let</span> view5 = <span class="hljs-type">View</span>()
<span class="hljs-keyword">let</span> view6 = <span class="hljs-type">View</span>()
<span class="hljs-keyword">let</span> view7 = <span class="hljs-type">View</span>()
<span class="hljs-keyword">let</span> view8 = <span class="hljs-type">View</span>()

view1.addSubview(subview: view2)
view1.addSubview(subview: view3)
view3.addSubview(subview: view4)
view3.addSubview(subview: view5)
view4.addSubview(subview: view6)
view6.addSubview(subview: view7)
view6.addSubview(subview: view8)</code></pre><br>形成的树形结构如下图：<br><img src="/images/viewhierarchy.png" alt=""></p>
<p>这也是我们常说的UIView层级。</p>
<h2 id="桥接模式（Bridge）"><a href="#桥接模式（Bridge）" class="headerlink" title="桥接模式（Bridge）"></a>桥接模式（Bridge）</h2><p>桥接模式是把抽象部分和实现部分分离，使它们都可以独立的变化。</p>
<p>由于暂未发现iOS系统框架中特别典型的适配器模式，而在贝聊APP和第三方库我也没遇到过，本文就以<a href="https://github.com/ochococo/Design-Patterns-In-Swift">Design-Patterns-In-Swift</a>的例子为例：<br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Switch</span> </span>&#123;
    <span class="hljs-keyword">var</span> appliance: <span class="hljs-type">Appliance</span> &#123;<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>&#125;
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">turnOn</span><span class="hljs-params">()</span></span>
&#125;

<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Appliance</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RemoteControl</span>: <span class="hljs-title">Switch</span> </span>&#123;
    <span class="hljs-keyword">var</span> appliance: <span class="hljs-type">Appliance</span>

    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">turnOn</span><span class="hljs-params">()</span></span> &#123;
        <span class="hljs-keyword">self</span>.appliance.run()
    &#125;

    <span class="hljs-keyword">init</span>(appliance: <span class="hljs-type">Appliance</span>) &#123;
        <span class="hljs-keyword">self</span>.appliance = appliance
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TV</span>: <span class="hljs-title">Appliance</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"tv turned on"</span>);
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacuumCleaner</span>: <span class="hljs-title">Appliance</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"vacuum cleaner turned on"</span>)
    &#125;
&#125;</code></pre><br>用法：<br><pre><code class="hljs swift"><span class="hljs-keyword">var</span> tvRemoteControl = <span class="hljs-type">RemoteControl</span>(appliance: <span class="hljs-type">TV</span>())
tvRemoteControl.turnOn()

<span class="hljs-keyword">var</span> fancyVacuumCleanerRemoteControl = <span class="hljs-type">RemoteControl</span>(appliance: <span class="hljs-type">VacuumCleaner</span>())
fancyVacuumCleanerRemoteControl.turnOn()</code></pre></p>
<h2 id="装饰器模式（Decorator）"><a href="#装饰器模式（Decorator）" class="headerlink" title="装饰器模式（Decorator）"></a>装饰器模式（Decorator）</h2><p>装饰器模式，也叫装饰者模式，能够实现动态的为对象添加功能，是从一个对象外部来给对象添加功能。装饰器模式就是基于对象组合的方式，可以很灵活的给对象添加所需要的功能。</p>
<p>根据具体实现方式的不同，分类装饰器和对象装饰器两种模式。</p>
<p>类装饰器模式，就是直接扩展现有的类，不新增一个类。swift中的extension特性对应的就是类装饰器模式。比如想给UIImage增加一个ratio的属性，直接extenstion UIImage类即可：<br><pre><code class="hljs swift"><span class="hljs-keyword">import</span> UIKit

<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">UIImage</span> </span>&#123;
  <span class="hljs-keyword">var</span> ratio: <span class="hljs-type">CGFloat</span> &#123;
    <span class="hljs-keyword">return</span> size.height / size.width
  &#125;
&#125;</code></pre><br>使用起来也很方便：<br><pre><code class="hljs swift"><span class="hljs-keyword">let</span> image = <span class="hljs-type">UIImage</span>(named: <span class="hljs-string">"sampleImage"</span>)!
<span class="hljs-built_in">print</span>(image.ratio)</code></pre><br>对象装饰器模式，是新增一个装饰类，然后持有一个被装饰类，通过给装饰类添加功能，增加被装饰类的功能。在UIKit中，UIView与CALayer，UIViewController与UIView是典型的对象装饰器模式。</p>
<p>UIView装饰了CALayer，给CALayer添加了事件响应等全新的功能。UIViewController装饰了UIView，给UIView添加了viewDidLoad、viewDidAppear 、viewWillAppear、viewWillDisappear 、viewDidDisappear、viewDidLayoutSubviews等生命周期，UIViewController带UIView来到了全新的世界的同时，也把自己演变成身份十分独特的控制器类，进而成就了经典的MVC设计模式。</p>
<p>比如UIView装饰CALayer的简易实现（为不与系统UIView混淆，这里取View）如下：<br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">View</span>: <span class="hljs-title">UIResponder</span>, <span class="hljs-title">CALayerDelegate</span> </span>&#123;
  <span class="hljs-comment">// 被装饰的layer</span>
  <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> layer: <span class="hljs-type">CALayer</span> = &#123;
    <span class="hljs-keyword">let</span> layer = <span class="hljs-type">CALayer</span>()
    <span class="hljs-comment">// 注意layer的delegate是View本身</span>
    layer.delegate = <span class="hljs-keyword">self</span>
    <span class="hljs-keyword">return</span> layer
  &#125;()
  
  <span class="hljs-comment">// 需要将CALayer功能暴露给外界的接口</span>
  <span class="hljs-keyword">var</span> frame: <span class="hljs-type">CGRect</span> &#123;
    <span class="hljs-keyword">set</span> &#123;
      layer.frame = newValue
    &#125;
    <span class="hljs-keyword">get</span> &#123;
      <span class="hljs-keyword">return</span> layer.frame
    &#125;
  &#125;
  <span class="hljs-comment">// 给CALayer新增加的事件响应功能</span>
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">touchesBegan</span><span class="hljs-params">(<span class="hljs-number">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> &#123;
    
  &#125;
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">touchesMoved</span><span class="hljs-params">(<span class="hljs-number">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> &#123;
    
  &#125;
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">touchesEnded</span><span class="hljs-params">(<span class="hljs-number">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> &#123;
    
  &#125;
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">touchesCancelled</span><span class="hljs-params">(<span class="hljs-number">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> &#123;

  &#125;
&#125;</code></pre><br>可以定义一些接口，将被装饰的类的功能暴露给外界。</p>
<h2 id="外观模式（Facade）"><a href="#外观模式（Facade）" class="headerlink" title="外观模式（Facade）"></a>外观模式（Facade）</h2><p>外观模式为子系统中的一组接口提供一个统一的更高层次的接口，使得子系统更加容易使用，说白了就是为了简化复杂的接口。</p>
<p><img src="/images/facade.jpg" alt=""></p>
<p>iOS系统框架中特别典型的外观模式暂未发现，其实我们常用的SDWebImage和YYWebImage在API设计上都采用了典型的外观模式。</p>
<p>例如想从一个URL加载图片：<br><pre><code class="hljs swift"><span class="hljs-keyword">import</span> UIKit
<span class="hljs-keyword">import</span> SDWebImage

<span class="hljs-keyword">let</span> imageView = <span class="hljs-type">UIImageView</span>()
imageView.sd_setImage(with: <span class="hljs-type">URL</span>(string: <span class="hljs-string">"http://www.domain.com/path/to/image.jpg"</span>),
                      placeholderImage: <span class="hljs-type">UIImage</span>(named: <span class="hljs-string">"placeholder.png"</span>))</code></pre><br>看似把URL直接传入UIImageView的<code>sd_setImage(with:placeholderImage:)</code>方法这么简单，其实从服务器加载图片其实是一个比较复杂的过程，主要涉及三个模块：</p>
<ol>
<li>缓存管理模块，查看有没有对应的缓存，以及缓存一张图片到磁盘或者内存</li>
<li>图片下载模块</li>
<li>网络请求模块，图片下载模块又依赖网络请求模块</li>
</ol>
<pre><code class="hljs swift"><span class="hljs-keyword">import</span> UIKit
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">UIImageView</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setImage</span><span class="hljs-params">(with url: URL, placeHolder: UIImage)</span></span> &#123;
    <span class="hljs-keyword">let</span> imageCacher = <span class="hljs-type">ImageCacher</span>.shared
    <span class="hljs-keyword">let</span> imageDownloader = <span class="hljs-type">ImageDownloader</span>.shared
    
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> cachedImage = imageCacher.cachedImageFor(url: url) &#123;
      image = cachedImage
      <span class="hljs-keyword">return</span>
    &#125;

    image = placeholder
    imageDownloader.downloadImageFrom(url: url) &#123; (image, error) <span class="hljs-keyword">in</span>
      <span class="hljs-keyword">self</span>.image = image
      <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> image = image &#123;
        imageCacher.cache(image: image, url: url)
      &#125;
    &#125;
  &#125;
&#125;</code></pre>
<p>其中依赖了缓存管理模块和图片下载模块：<br><pre><code class="hljs swift"><span class="hljs-comment">// 图片下载模块</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageDownloader</span> </span>&#123;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared = <span class="hljs-type">ImageDownloader</span>()
  
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">downloadImageFrom</span><span class="hljs-params">(url: URL, completionHandler:@escaping <span class="hljs-params">(UIImage?, Error?)</span></span></span> -&gt; <span class="hljs-type">Void</span>) &#123;
    <span class="hljs-comment">// 用到了网络下载模块</span>
    <span class="hljs-keyword">let</span> downloadTask = <span class="hljs-type">URLSession</span>.shared.dataTask(with: url, completionHandler: &#123; (data, response, error) <span class="hljs-keyword">in</span>
      <span class="hljs-type">DispatchQueue</span>.main.async &#123;
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> imageData = data &#123;
          <span class="hljs-keyword">let</span> image = <span class="hljs-type">UIImage</span>(data: imageData)
          completionHandler(image, <span class="hljs-literal">nil</span>)
        &#125; <span class="hljs-keyword">else</span> &#123;
          completionHandler(<span class="hljs-literal">nil</span>, error)
        &#125;
      &#125;
    &#125;)
    downloadTask.resume()
  &#125;
&#125;

<span class="hljs-comment">// 图片缓存模块</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageCacher</span> </span>&#123;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared = <span class="hljs-type">ImageCacher</span>()
  
  <span class="hljs-comment">// 从缓存中取缓存的UIImage，没有就返回nil</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cachedImageFor</span><span class="hljs-params">(url: URL)</span></span> -&gt; <span class="hljs-type">UIImage?</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
  &#125;
  
  <span class="hljs-comment">// 缓存图片</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cache</span><span class="hljs-params">(image: UIImage, url: URL)</span></span> &#123;
    <span class="hljs-comment">// 缓存逻辑</span>
  &#125;
&#125;</code></pre><br>使用起来跟SDWebImage一般无二：<br><pre><code class="hljs swift"><span class="hljs-keyword">let</span> imageView = <span class="hljs-type">UIImageView</span>()
imageView.setImage(with: <span class="hljs-type">URL</span>(string: <span class="hljs-string">"http://www.domain.com/path/to/image.jpg"</span>),
                   placeholder: <span class="hljs-type">UIImage</span>(named: <span class="hljs-string">"placeholder.png"</span>))</code></pre></p>
<h2 id="享元模式（Flyweight）"><a href="#享元模式（Flyweight）" class="headerlink" title="享元模式（Flyweight）"></a>享元模式（Flyweight）</h2><p>享元模式就是实现类的复用，因为当相同的类创建很多，会消耗很大系统内存。在UIKit中，UITableViewCell和UICollectionViewCell的复用就是典型的享元模式，如果UITableViewCell和UICollectionViewCell不复用，每一个cell都需要创建新的实例，不但消耗内存，同时也消耗时间，进而导致卡顿掉帧。</p>
<p>我们在使用UITableViewCell时，一般分为四步：</p>
<ol>
<li>定义一个自定义cell</li>
<li>创建tableview</li>
<li>注册cell</li>
<li>从cell池（由tableView维护）取cell</li>
</ol>
<pre><code class="hljs swift"><span class="hljs-keyword">import</span> UIKit
<span class="hljs-comment">// 1. 定义一个自定义cell</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomCell</span>: <span class="hljs-title">UITableViewCell</span> </span>&#123; &#125;
<span class="hljs-comment">// 2. 创建tableview</span>
<span class="hljs-keyword">let</span> tableView = <span class="hljs-type">UITableView</span>()
<span class="hljs-comment">// 3. 注册cell</span>
tableView.register(<span class="hljs-type">CustomCell</span>.<span class="hljs-keyword">self</span>, forCellReuseIdentifier: <span class="hljs-type">String</span>(describing: <span class="hljs-type">CustomCell</span>.<span class="hljs-keyword">self</span>))
<span class="hljs-comment">// 4. 从cell池取cell</span>
<span class="hljs-keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="hljs-type">String</span>(describing: <span class="hljs-type">CustomCell</span>.<span class="hljs-keyword">self</span>))</code></pre>
<p>UITableViewCell复用逻辑的简易实现（为不与系统UITableView混淆，这里取TableView），如下：<br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TableView</span>: <span class="hljs-title">UIScrollView</span> </span>&#123;
  <span class="hljs-comment">// 注册的cell class</span>
  <span class="hljs-keyword">var</span> registerredCellClasses: [<span class="hljs-type">String</span>: <span class="hljs-type">UIKit</span>.<span class="hljs-type">UITableViewCell</span>.<span class="hljs-type">Type</span>] = [:]
  <span class="hljs-comment">// cell池</span>
  <span class="hljs-keyword">var</span> cellPool: [<span class="hljs-type">String</span>: [<span class="hljs-type">UITableViewCell</span>]] = [:]
  
  <span class="hljs-comment">// 注册复用的cell</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-number">_</span> cellClass: UIKit.UITableViewCell.<span class="hljs-keyword">Type</span>, forCellReuseIdentifier identifier: String)</span></span> &#123;
    registerredCellClasses[identifier] = cellClass
  &#125;
  
  <span class="hljs-comment">// 复用cell方法</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dequeueReusableCell</span><span class="hljs-params">(withIdentifier identifier: String)</span></span> -&gt; <span class="hljs-type">UITableViewCell?</span> &#123;
    <span class="hljs-comment">// 检查有没注册</span>
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> cellClass = registerredCellClasses[identifier] <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">var</span> cells = cellPool[identifier],
      cells.<span class="hljs-built_in">count</span> &gt; <span class="hljs-number">0</span> &#123;
      <span class="hljs-comment">// 检查cell池中有没有可复用的cell</span>
      <span class="hljs-keyword">let</span> cell = cells.removeFirst()
      cellPool[identifier] = cells
      
      <span class="hljs-comment">// 准备复用</span>
      cell.prepareForReuse()
      
      <span class="hljs-keyword">return</span> cell
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-comment">// cell池没有可复用的cell，新创建一个</span>
      <span class="hljs-keyword">let</span> cell = cellClass.<span class="hljs-keyword">init</span>(style: .<span class="hljs-keyword">default</span>, reuseIdentifier: identifier)
      <span class="hljs-keyword">return</span> cell
    &#125;
  &#125;
  
  <span class="hljs-comment">// 回收超出屏幕可视区域的cell，</span>
  <span class="hljs-comment">// TableView会监测正在显示cell的状态，当有cell完全进入不可视区域时，进行回收，逻辑比较复杂，这里不实现了</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">collectCellInvisible</span><span class="hljs-params">(invisibleCell: UITableViewCell)</span></span> &#123;
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> identifier = invisibleCell.reuseIdentifier <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;
    cellPool[identifier]?.append(invisibleCell)
  &#125;
&#125;</code></pre><br>实现中，</p>
<ol>
<li>需要记录注册cell和维护一个cell池。</li>
<li>当调用dequeueReusableCell(withIdentifier:)方法时，会先判断对应idenfitier有没注册的cell，确定有注册后，然后再看现有的cell池有没有可以复用的，有就复用，没有就直接创建一个新的cell。</li>
<li>TableView需要监测正在显示cell的状态，当有cell完全进入不可视区域时，进行回收。</li>
</ol>
<h2 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h2><p>代理模式是为其他对象提供一种代理以控制这个对象的访问，解决直接访问某些对象时出现的问题。</p>
<p><code>Foundation</code>中的<code>NSProxy</code>采用的就是代理模式，但我们日常开发并不常用，本文就以<a href="https://github.com/ochococo/Design-Patterns-In-Swift">Design-Patterns-In-Swift</a>的例子为例：<br><pre><code class="hljs swift"><span class="hljs-keyword">import</span> UIKit
<span class="hljs-comment">// 专门负责开门的操作人员，不负责身份校验</span>
<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">DoorOperator</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">String</span>
&#125;

<span class="hljs-comment">// 中南海开门操作人员</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SeaPalaceDoorOperater</span> : <span class="hljs-title">DoorOperator</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">String</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">"中南海欢迎您！"</span>
  &#125;
&#125;

<span class="hljs-comment">// 中南海开门操作人员的代理，除了开门职责外，还负责校验身份</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SeaPalaceDoorOperaterProxy</span> : <span class="hljs-title">DoorOperator</span> </span>&#123;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> doorOperator: <span class="hljs-type">SeaPalaceDoorOperater!</span>
  
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">authenticate</span><span class="hljs-params">(password: String)</span></span> -&gt; <span class="hljs-type">Bool</span> &#123;
    <span class="hljs-keyword">guard</span> password == <span class="hljs-string">"pass"</span> <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    &#125;
    
    doorOperator = <span class="hljs-type">SeaPalaceDoorOperater</span>()
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  &#125;
  
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">String</span> &#123;
    <span class="hljs-keyword">guard</span> doorOperator != <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-string">"对不起，您没有开门权限"</span>
    &#125;
    
    <span class="hljs-keyword">return</span> doorOperator.<span class="hljs-keyword">open</span>()
  &#125;
&#125;</code></pre><br>其中开门的操作人员DoorOperator只有开门这一单一职责，但开门是需要校验的，所以需要一个DoorOperator的代理，让其承担一部分校验的职责，具体开门的还是由被代理的DoorOperator来。这其实跟装饰者模式有点像，只是代理模式更关注对被代理类的控制，就像SeaPalaceDoorOperaterProxy主要控制外界对被其代理对象SeaPalaceDoorOperater的访问。</p>
<p>具体用法如下：<br><pre><code class="hljs swift"><span class="hljs-keyword">let</span> seaPalaceDoorOperater = <span class="hljs-type">SeaPalaceDoorOperaterProxy</span>()
seaPalaceDoorOperater.<span class="hljs-keyword">open</span>()

seaPalaceDoorOperater.authenticate(password: <span class="hljs-string">"pass"</span>)
seaPalaceDoorOperater.<span class="hljs-keyword">open</span>()</code></pre></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在iOS系统框架中，</p>
<ol>
<li>UIView和CALayer是典型的组合模式。</li>
<li>swift中的extension是典型的类装饰器模式。</li>
<li>UIView与CALayer，UIViewController与UIView是典型的对象装饰器模式。</li>
<li>UITableViewCell与UICollectionViewCell的复用机制是典型的享元模式。</li>
<li>苹果<a href="https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/CocoaDesignPatterns/CocoaDesignPatterns.html#//apple_ref/doc/uid/TP40002974-CH6-SW6">官方资料</a>说protocol是变相的适配器模式，我还能说什么。</li>
</ol>
<p>在贝聊App的项目中，云望消息类型转换到贝聊消息类型是典型的适配器模式。</p>
<p>在第三方框架SDWebImage中，UIImageView的<code>sd_setImage(with:placeholderImage:)</code>等下载网络图片的便捷方法是典型的外观模式。</p>
<p>而桥接模式和代理模式，由于未找到合适的例子，采用了<a href="https://github.com/ochococo/Design-Patterns-In-Swift">Design-Patterns-In-Swift</a>中的例子。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://www.raywenderlich.com/46988/ios-design-patterns">iOS Design Patterns</a></li>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift">Design-Patterns-In-Swift</a></li>
<li><a href="https://zhongwuzw.github.io/2016/09/08/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BSDWebImage/">源码分析之SDWebImage</a></li>
<li><a href="https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/CocoaDesignPatterns/CocoaDesignPatterns.html#//apple_ref/doc/uid/TP40002974-CH6-SW6">Cocoa Design Patterns</a></li>
</ol>

        </div>
        
        <div class="level is-size-7 is-uppercase">
            <div class="level-start">
                <div class="level-item">
                    <span class="is-size-6 has-text-grey has-mr-7">#</span>
                    <a class="has-link-grey -link" href="/tags/design-pattern/" rel="tag">design pattern</a>, <a class="has-link-grey -link" href="/tags/iOS/" rel="tag">iOS</a>
                </div>
            </div>
        </div>
        
        
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3>
        <div class="buttons is-centered">
            
                
<a class="button is-success donate">
    <span class="icon is-small">
        <i class="fab fa-weixin"></i>
    </span>
    <span>微信</span>
    <div class="qrcode"><img src="/images/wechat_pay.jpg" alt="微信"></div>
</a>

                
        </div>
    </div>
</div>



<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        <div class="level-start">
            <a class="level level-item has-link-grey  article-nav-prev" href="/2017/03/22/gitcommit/">
                <i class="level-item fas fa-chevron-left"></i>
                <span class="level-item">commit和branch理解深入</span>
            </a>
        </div>
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/2017/03/11/creationalDesignPattern/">
                <span class="level-item">《创建型设计模式》之iOS系统框架实践</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>


</div>
                
                




<div
    class="column is-3-tablet is-3-desktop is-3-widescreen  has-order-3 column-right ">
    
    <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            链接
        </h3>
        <ul class="menu-list">
        
            <li>
                <a class="level is-mobile" href="https://weibo.com/shellhue" target="_blank" rel="noopener">
                    <span class="level-left">
                        <span class="level-item">我的微博</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">weibo.com</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="https://www.zhihu.com/people/huang-ze-yu-51-15" target="_blank" rel="noopener">
                    <span class="level-left">
                        <span class="level-item">我的专栏</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">www.zhihu.com</span>
                    </span>
                </a>
            </li>
        
        </ul>
        </div>
    </div>
</div>

    
    <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            最新文章
        </h3>
        
        <article class="media">
            
            <a href="/2020/06/13/workonce/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/workonce_1.jpg" alt="一劳永逸的财富观">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-06-12T16:02:23.000Z">2020-06-13</time></div>
                    <a href="/2020/06/13/workonce/" class="title has-link-black-ter is-size-6 has-text-weight-normal">一劳永逸的财富观</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/06/10/fpn/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/fpn_1.png" alt="一文看尽物体检测中的各种FPN">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-06-10T15:35:29.000Z">2020-06-10</time></div>
                    <a href="/2020/06/10/fpn/" class="title has-link-black-ter is-size-6 has-text-weight-normal">一文看尽物体检测中的各种FPN</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/06/07/aitop/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/deep_learning_floor.jpg" alt="当前深度学习算法工程师的职业天花板">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-06-07T14:35:29.000Z">2020-06-07</time></div>
                    <a href="/2020/06/07/aitop/" class="title has-link-black-ter is-size-6 has-text-weight-normal">当前深度学习算法工程师的职业天花板</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/05/10/investment/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/investment_1.jpg" alt="要做短线投机之前，先做一个简单的数学题">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-05-10T15:35:29.000Z">2020-05-10</time></div>
                    <a href="/2020/05/10/investment/" class="title has-link-black-ter is-size-6 has-text-weight-normal">要做短线投机之前，先做一个简单的数学题</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/04/28/efficientnet/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/efficientnet_1.png" alt="细说EfficientNet">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-04-28T15:35:29.000Z">2020-04-28</time></div>
                    <a href="/2020/04/28/efficientnet/" class="title has-link-black-ter is-size-6 has-text-weight-normal">细说EfficientNet</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
    
    <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                标签
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Machine-Learning/">
                        <span class="tag">Machine Learning</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/design-pattern/">
                        <span class="tag">design pattern</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/git/">
                        <span class="tag">git</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/iOS/">
                        <span class="tag">iOS</span>
                        <span class="tag is-grey">9</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/leetcode/">
                        <span class="tag">leetcode</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">
                        <span class="tag">人工智能</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/%E5%B0%8F%E7%BA%B8%E5%B1%91/">
                        <span class="tag">小纸屑</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/%E6%84%9F%E6%82%9F/">
                        <span class="tag">感悟</span>
                        <span class="tag is-grey">5</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/%E6%85%A2%E6%8A%95%E8%B5%84/">
                        <span class="tag">慢投资</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/%E7%89%A9%E4%BD%93%E6%A3%80%E6%B5%8B/">
                        <span class="tag">物体检测</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
    
    
</div>

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/../images/logo.png" alt="《结构型设计模式》之iOS系统框架实践" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2020 轻墨&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a>
                
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>


<script>
var IcarusThemeSettings = {
    site: {
        url: 'http://yoursite.com',
        external_link: {"enable":true,"exclude":[]}
    },
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>





<script src="/js/animation.js"></script>



<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
<script src="/js/gallery.js" defer></script>



<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>


<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>














<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

</html>