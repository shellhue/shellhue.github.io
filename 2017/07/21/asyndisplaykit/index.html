<!DOCTYPE html>
<html  lang="zh">

<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />

<meta name="generator" content="Hexo 4.2.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>AsyncDisplayKit近一年的使用体会及疑难点 - 轻墨</title>


    <meta name="description" content="一个第三方库能做到像新产品一样，值得大家去写写使用体会的，并不多见，AsyncDisplayKit却完全可以，因为AsyncDisplayKit不仅仅是一个工具，它更像一个系统UI框架，改变整个编码体验。也正是这种极强的侵入性，导致不少听过、star过，甚至下过demo跑过AsyncDisplayKit的你我，望而却步，驻足观望。但列表界面稍微复杂时，烦人的高度计算，因为性能不得不放弃Autola">
<meta property="og:type" content="article">
<meta property="og:title" content="AsyncDisplayKit近一年的使用体会及疑难点">
<meta property="og:url" content="http://yoursite.com/2017/07/21/asyndisplaykit/index.html">
<meta property="og:site_name" content="轻墨">
<meta property="og:description" content="一个第三方库能做到像新产品一样，值得大家去写写使用体会的，并不多见，AsyncDisplayKit却完全可以，因为AsyncDisplayKit不仅仅是一个工具，它更像一个系统UI框架，改变整个编码体验。也正是这种极强的侵入性，导致不少听过、star过，甚至下过demo跑过AsyncDisplayKit的你我，望而却步，驻足观望。但列表界面稍微复杂时，烦人的高度计算，因为性能不得不放弃Autola">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/images/asyncdisplaykit.png">
<meta property="article:published_time" content="2017-07-21T06:35:29.000Z">
<meta property="article:modified_time" content="2020-02-09T16:34:11.026Z">
<meta property="article:author" content="轻墨">
<meta property="article:tag" content="iOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/asyncdisplaykit.png">







<link rel="icon" href="/../images/logo.png">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
<style>body>.footer,body>.navbar,body>.section{opacity:0}</style>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/back-to-top.css">

    
    
    
    
    
    
    
    <link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
    
    
    


<link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body class="is-2-column">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/../images/logo.png" alt="AsyncDisplayKit近一年的使用体会及疑难点" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/.">首页</a>
                
                <a class="navbar-item"
                href="/archives">归档</a>
                
                <a class="navbar-item"
                href="/tags">标签</a>
                
                <a class="navbar-item"
                href="/about">关于</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    <a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/shellhue">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-9-tablet is-9-desktop is-9-widescreen has-order-2 column-main">
<div class="card">
    
    <div class="card-image">
        <span  class="image is-7by1">
            <img class="thumbnail" src="/images/asyncdisplaykit.png" alt="AsyncDisplayKit近一年的使用体会及疑难点">
        </span>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-07-21T06:35:29.000Z">2017-07-21</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    41 分钟 读完 (大约 6169 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                AsyncDisplayKit近一年的使用体会及疑难点
            
        </h1>
        <div class="content">
            <p>一个第三方库能做到像新产品一样，值得大家去写写使用体会的，并不多见，<code>AsyncDisplayKit</code>却完全可以，因为<code>AsyncDisplayKit</code>不仅仅是一个工具，它更像一个系统UI框架，改变整个编码体验。也正是这种极强的侵入性，导致不少听过、star过，甚至下过demo跑过<code>AsyncDisplayKit</code>的你我，望而却步，驻足观望。但列表界面稍微复杂时，烦人的高度计算，因为性能不得不放弃<code>Autolayout</code>而选择上古时代的<code>frame layout</code>，令人精疲力尽，这时<code>AsyncDisplayKit</code>总会不自然浮现眼前，让你跃跃欲试。</p>
<p>去年10月份，我们入坑了。</p>
<p>当时还只是拿简单的列表页试水，基本上手后，去年底在稍微空闲的时候用<code>AsyncDisplayKit</code>重构了帖子详情，今年三月份，又借着公司聊天增加群聊的契机，用<code>AsyncDisplayKit</code>重构整个聊天。林林总总，从简单到复杂，踩过的坑大大小小，将近一年的时光转眼飞逝，可以写写总结了。</p>
<h1 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h1><p>先说说学习曲线，这是大家都比较关心的问题。<br><a id="more"></a><br>跟大多人一样，一开始我以为<code>AsyncDisplayKit</code>会像<code>Rxswift</code>等<code>MVVM</code>框架一样，有着陡峭的学习曲线。但事实上，<code>AsyncDisplayKit</code>的学习曲线还算平滑。</p>
<p>主要是因为<code>AsyncDisplayKit</code>只是对<code>UIKit</code>的再一次封装，基本沿用了<code>UIKit</code>的<code>API</code>设计，大部分情况下，只是将<code>view</code>改成<code>node</code>，<code>UI</code>前缀改为<code>AS</code>，写着写着，恍惚间，你以为自己还是在写<code>UIKit</code>呢。</p>
<p>比如<code>ASDisplayNode</code>与<code>UIView</code>：<br><pre><code class="hljs swift"><span class="hljs-keyword">let</span> nodeA = <span class="hljs-type">ASDisplayNode</span>()
<span class="hljs-keyword">let</span> nodeB = <span class="hljs-type">ASDisplayNode</span>()
<span class="hljs-keyword">let</span> nodeC = <span class="hljs-type">ASDisplayNode</span>()
nodeA.addSubnode(nodeB)
nodeA.addSubnode(nodeC)
nodeA.backgroundColor = .red
nodeA.frame = <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>, width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span>)
nodeC.removeFromSupernode()

<span class="hljs-keyword">let</span> viewA = <span class="hljs-type">UIView</span>()
<span class="hljs-keyword">let</span> viewB = <span class="hljs-type">UIView</span>()
<span class="hljs-keyword">let</span> viewC = <span class="hljs-type">UIView</span>()
viewA.addSubview(viewB)
viewA.addSubview(viewC)
viewA.backgroundColor = .red
viewA.frame = <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>, width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span>)
viewC.removeFromSuperview()</code></pre><br>相信你看两眼也就摸出门道了，大部分API一模一样。</p>
<p>真正发生翻天覆地变化的是布局方式，<code>AsyncDisplayKit</code>用的是<code>flexbox</code>布局，<code>UIView</code>使用的是<code>Autolayout</code>。用<code>AsyncDisplayKit</code>的<code>flexbox</code>布局替代<code>Autolayout</code>布局，完全不亚于用<code>Autolayout</code>替换<code>frame</code>布局的蜕变，需要比较大的观念转变。</p>
<p>但<code>flexbox</code>布局被提出已久，且其本身直观简单，较容易上手，学习曲线只是略陡峭。</p>
<p>这里有一个学习<code>AsyncDisplayKit</code>布局的<a href="http://huytnguyen.me/froggy-asdk-layout/">小游戏</a>，简单有趣，可以一玩。</p>
<p>整体上两天即可上手，无须担心学习曲线问题。</p>
<h1 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h1><p>当过了上手的艰难阶段后，才是真正开始体会<code>AsyncDisplayKit</code>的时候。用了将近一年，有几点<code>AsyncDisplayKit</code>的优势相当明显：</p>
<p>1）<code>cell</code>中再也不用算高度和位置等<code>frame</code>信息了<br>这是非常非常非常非常诱人的，当<code>cell</code>中有动态文本时，文本的高度计算很费神，计算完，还得缓存，如果再加上其他动态内容，比如有时候没图片，那<code>frame</code>算起来，简直让人想哭，而如果用<code>AsyncDisplayKit</code>，所有的<code>height</code>、<code>frame</code>计算都烟消云散，甚至都不知道<code>frame</code>这个东西存在过，很酸爽。</p>
<p>2）一帧不掉<br>平时界面稍微动态点，元素稍微多点，<code>Autolayout</code>的性能就不堪重用，而上古时代的<code>frame</code>布局在高效缓存的基础上确实可以做到高性能，但<code>frame</code>缓存的维护和计算都不是一般的复杂，而<code>AsyncDisplayKit</code>却能在保持简介布局的同时，做到一帧不掉，这是多么的让人感动！</p>
<p>3）更优雅的架构设计<br>前两点好处是用<code>AsyncDisplayKit</code>最直接最容易被感受到的，其实，当深入使用时，你会发现，<code>AsyncDisplayKit</code>还会给程序架构设计带来一些改变，会使原本复杂的架构变得更简单，更优雅，更灵活，更容易维护，更容易扩展，也会使整个代码更容易理解，而这个影响是深远的，毕竟代码是写给别人看的。</p>
<p>但<code>AsyncDisplayKit</code>有一个极其著名的问题，闪烁。</p>
<p>当我们开始试水使用<code>AsyncDisplayKit</code>时，只要简单<code>reload</code>一下<code>TableNode</code>，那闪烁，眼睛都瞎了。后来查了官方的<code>issue</code>，才发现很多人都提了这个问题，但官方也没给出什么优雅的解决方案。要知道，闪烁是非常影响用户体验的。如果非要在不闪烁和带闪烁的<code>AsyncDisplayKit</code>中选择，我会毫不犹豫的选择不闪烁，而放弃使用<code>AsyncDisplayKit</code>。但现在已经不存在这个选择了，因为经过<code>AsyncDisplayKit</code>的多次迭代努力加上一些小技巧，<code>AsyncDisplayKit</code>的异步闪烁已经被优雅的解决了。</p>
<p>但<code>AsyncDisplayKit</code>不宜广泛使用，那些高度固定、<code>UI</code>简单用<code>UIKit</code>更好一些，毕竟<code>AsyncDisplayKit</code>并不像<code>UIKit</code>，人人都会，如果内容和高度复杂又很动态，强烈推荐<code>AsyncDisplayKit</code>，它会简化太多东西。</p>
<h1 id="疑难点"><a href="#疑难点" class="headerlink" title="疑难点"></a>疑难点</h1><p>一年的<code>AsyncDisplayKit</code>使用经验，踩过了不少坑，遇到了不少值得注意的问题，一并列在这里，以供参考。</p>
<h2 id="ASNetworkImageNode的缓存"><a href="#ASNetworkImageNode的缓存" class="headerlink" title="ASNetworkImageNode的缓存"></a>ASNetworkImageNode的缓存</h2><p><code>ASNetworkImageNode</code>是对<code>UIImageView</code>需要从网络加载图片这一使用场景的封装，省去了<code>YYWebImage</code>或者<code>SDWebImage</code>等第三方库的引入，只需要设置<code>URL</code>即可实现网络图片的自动加载。</p>
<pre><code class="hljs swift"><span class="hljs-keyword">import</span> AsyncDisplayKit

<span class="hljs-keyword">let</span> avatarImageNode = <span class="hljs-type">ASNetworkImageNode</span>()
avatarImageNode.url = <span class="hljs-type">URL</span>(string: <span class="hljs-string">"http://shellhue.github.io/images/log.png"</span>)</code></pre>
<p>这非常省事便捷，但<code>ASNetworkImageNode</code>默认用的缓存机制和图片下载器是<code>PinRemoteImage</code>，为了使用我们自己的缓存机制和图片下载器，需要实现<code>ASImageCacheProtocol</code>图片缓存协议和 <code>ASImageDownloaderProtocol</code>图片下载器协议两个协议，然后初始化时，用<code>ASNetworkImageNode</code>的<code>init(cache: ASImageCacheProtocol, downloader: ASImageDownloaderProtocol)</code>初始化方法，传入对应的类，方便其间，一般会自定义一个初始化静态方法。我们公司缓存机制和图片下载器都是用的<code>YYWebImage</code>，桥接代码如下。</p>
<pre><code class="hljs swift"><span class="hljs-keyword">import</span> YYWebImage
<span class="hljs-keyword">import</span> AsyncDisplayKit

<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ASNetworkImageNode</span> </span>&#123;
  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">imageNode</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">ASNetworkImageNode</span> &#123;
    <span class="hljs-keyword">let</span> manager = <span class="hljs-type">YYWebImageManager</span>.shared()
    <span class="hljs-keyword">return</span> <span class="hljs-type">ASNetworkImageNode</span>(cache: manager, downloader: manager)
  &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">YYWebImageManager</span>: <span class="hljs-title">ASImageCacheProtocol</span>, <span class="hljs-title">ASImageDownloaderProtocol</span> </span>&#123;
  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">downloadImage</span><span class="hljs-params">(with URL: URL,
                            callbackQueue: DispatchQueue,
                            downloadProgress: AsyncDisplayKit.ASImageDownloaderProgress?,
                            completion: @escaping AsyncDisplayKit.ASImageDownloaderCompletion)</span></span> -&gt; <span class="hljs-type">Any?</span> &#123;
    <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> operation: <span class="hljs-type">YYWebImageOperation?</span>
    operation = requestImage(with: <span class="hljs-type">URL</span>,
                             options: .setImageWithFadeAnimation,
                             progress: &#123; (received, expected) -&gt; <span class="hljs-type">Void</span> <span class="hljs-keyword">in</span>
                              callbackQueue.async(execute: &#123;
                                <span class="hljs-keyword">let</span> progress = expected == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : received / expected
                                downloadProgress?(<span class="hljs-type">CGFloat</span>(progress))
                              &#125;)
    &#125;, transform: <span class="hljs-literal">nil</span>, completion: &#123; (image, url, from, state, error) <span class="hljs-keyword">in</span>
      completion(image, error, operation)
    &#125;)
    
    <span class="hljs-keyword">return</span> operation
  &#125;
  
  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cancelImageDownload</span><span class="hljs-params">(forIdentifier downloadIdentifier: <span class="hljs-keyword">Any</span>)</span></span> &#123;
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> operation = downloadIdentifier <span class="hljs-keyword">as</span>? <span class="hljs-type">YYWebImageOperation</span> <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">return</span>
    &#125;
    operation.cancel()
  &#125;
  
  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cachedImage</span><span class="hljs-params">(with URL: URL, callbackQueue: DispatchQueue, completion: @escaping AsyncDisplayKit.ASImageCacherCompletion)</span></span> &#123;
    cache?.getImageForKey(cacheKey(<span class="hljs-keyword">for</span>: <span class="hljs-type">URL</span>), with: .all, with: &#123; (image, cacheType) <span class="hljs-keyword">in</span>
      callbackQueue.async &#123;
        completion(image)
      &#125;
    &#125;)
  &#125;
&#125;</code></pre>
<h2 id="闪烁"><a href="#闪烁" class="headerlink" title="闪烁"></a>闪烁</h2><p>初次使用<code>AsyncDisplayKit</code>，当享受其一帧不掉如丝般柔滑的手感时，<code>ASTableNode</code>和<code>ASCollectionNode</code>刷新时的闪烁一定让你几度崩溃，到<code>AsyncDisplayKit</code>的<code>github</code>上搜索闪烁相关issue，会出来100多个问题。闪烁是<code>AsyncDisplayKit</code>与生俱来的问题，闻名遐迩，而闪烁的体验非常糟糕。幸运的是，几经探索，<code>AsyncDisplayKit</code>的闪烁问题已经完美解决，这个完美指的是一帧不掉的同时没有任何闪烁，同时也没增加代码的复杂度。</p>
<p>闪烁可以分为四类，</p>
<h4 id="1）ASNetworkImageNode-reload时的闪烁"><a href="#1）ASNetworkImageNode-reload时的闪烁" class="headerlink" title="1）ASNetworkImageNode reload时的闪烁"></a>1）ASNetworkImageNode reload时的闪烁</h4><p>当<code>ASCellNode</code>中包含<code>ASNetworkImageNode</code>，则这个<code>cell reload</code>时，<code>ASNetworkImageNode</code>会异步从本地缓存或者网络请求图片，请求到图片后再设置<code>ASNetworkImageNode</code>展示图片，但在异步过程中，<code>ASNetworkImageNode</code>会先展示<code>PlaceholderImage</code>，从<code>PlaceholderImage</code>—-&gt;<code>fetched image</code>的展示替换导致闪烁发生，即使整个<code>cell</code>的数据没有任何变化，只是简单的<code>reload</code>，<code>ASNetworkImageNode</code>的图片加载逻辑依然不变，因此仍然会闪烁，这显著区别于<code>UIImageView</code>，因为<code>YYWebImage</code>或者<code>SDWebImage</code>对<code>UIImageView</code>的<code>image</code>设置逻辑是，先同步检查有无内存缓存，有的话直接显示，没有的话再先显示<code>PlaceholderImage</code>，等待加载完成后再显示加载的图片，也即逻辑是<code>memory cached image</code>—-&gt;<code>PlaceholderImage</code>—-&gt;<code>fetched image</code>的逻辑，刷新当前<code>cell</code>时，如果数据没有变化<code>memory cached image</code>一般都会有，因此不会闪烁。</p>
<p><code>AsyncDisplayKit</code>官方给的修复思路是：</p>
<pre><code class="hljs swift"><span class="hljs-keyword">import</span> AsyncDisplayKit

<span class="hljs-keyword">let</span> node = <span class="hljs-type">ASNetworkImageNode</span>()
node.placeholderColor = <span class="hljs-type">UIColor</span>.red
node.placeholderFadeDuration = <span class="hljs-number">3</span></code></pre>
<p>这样修改后，确实没有闪烁了，但这只是将<code>PlaceholderImage</code>—-&gt;<code>fetched image</code>图片替换导致的闪烁拉长到3秒而已，自欺欺人，并没有修复。</p>
<p>既然闪烁是<code>reload</code>时，没有事先同步检查有无缓存导致的，继承一个<code>ASNetworkImageNode</code>的子类，复写<code>url</code>设置逻辑：</p>
<pre><code class="hljs swift"><span class="hljs-keyword">import</span> AsyncDisplayKit

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkImageNode</span>: <span class="hljs-title">ASNetworkImageNode</span> </span>&#123;
  <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> url: <span class="hljs-type">URL?</span> &#123;
    <span class="hljs-keyword">didSet</span> &#123;
      <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> u = url,
        <span class="hljs-keyword">let</span> image = <span class="hljs-type">UIImage</span>.cachedImage(with: u) <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">self</span>.image = image
        placeholderEnabled = <span class="hljs-literal">false</span>
      &#125;
    &#125;
  &#125;
&#125;</code></pre>
<p>按道理不会闪烁了，但事实上仍然会，只要是个<code>ASNetworkImageNode</code>，无论怎么设置，都会闪，这与官方的API说明严重不符，很无语。迫不得已之下，当有缓存时，直接用<code>ASImageNode</code>替换<code>ASNetworkImageNode</code>。</p>
<pre><code class="hljs swift"><span class="hljs-keyword">import</span> AsyncDisplayKit

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkImageNode</span>: <span class="hljs-title">ASDisplayNode</span> </span>&#123;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> networkImageNode = <span class="hljs-type">ASNetworkImageNode</span>.imageNode()
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> imageNode = <span class="hljs-type">ASImageNode</span>()
  
  <span class="hljs-keyword">var</span> placeholderColor: <span class="hljs-type">UIColor?</span> &#123;
    <span class="hljs-keyword">didSet</span> &#123;
      networkImageNode.placeholderColor = placeholderColor
    &#125;
  &#125;
  
  <span class="hljs-keyword">var</span> image: <span class="hljs-type">UIImage?</span> &#123;
    <span class="hljs-keyword">didSet</span> &#123;
      networkImageNode.image = image
    &#125;
  &#125;
  
  <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> placeholderFadeDuration: <span class="hljs-type">TimeInterval</span> &#123;
    <span class="hljs-keyword">didSet</span> &#123;
      networkImageNode.placeholderFadeDuration = placeholderFadeDuration
    &#125;
  &#125;
  
  <span class="hljs-keyword">var</span> url: <span class="hljs-type">URL?</span> &#123;
    <span class="hljs-keyword">didSet</span> &#123;
      <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> u = url,
        <span class="hljs-keyword">let</span> image = <span class="hljs-type">UIImage</span>.cachedImage(with: u) <span class="hljs-keyword">else</span> &#123;
          networkImageNode.url = url
          <span class="hljs-keyword">return</span>
      &#125;
      
      imageNode.image = image
    &#125;
  &#125;
  
  <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>() &#123;
    <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()
    addSubnode(networkImageNode)
    addSubnode(imageNode)
  &#125;
  
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">layoutSpecThatFits</span><span class="hljs-params">(<span class="hljs-number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="hljs-type">ASLayoutSpec</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-type">ASInsetLayoutSpec</span>(insets: .zero,
                             child: networkImageNode.url == <span class="hljs-literal">nil</span> ? imageNode : networkImageNode)
  &#125;
  
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addTarget</span><span class="hljs-params">(<span class="hljs-number">_</span> target: <span class="hljs-keyword">Any</span>?, action: Selector, forControlEvents controlEvents: ASControlNodeEvent)</span></span> &#123;
    networkImageNode.addTarget(target, action: action, forControlEvents: controlEvents)
    imageNode.addTarget(target, action: action, forControlEvents: controlEvents)
  &#125;
&#125;</code></pre>
<p>使用时将<code>NetworkImageNode</code>当成<code>ASNetworkImageNode</code>使用即可。</p>
<h4 id="2）reload-单个cell时的闪烁"><a href="#2）reload-单个cell时的闪烁" class="headerlink" title="2）reload 单个cell时的闪烁"></a>2）reload 单个cell时的闪烁</h4><p>当<code>reload ASTableNode</code>或者<code>ASCollectionNode</code>的某个<code>indexPath</code>的<code>cell</code>时，也会闪烁。原因和<code>ASNetworkImageNode</code>很像，都是异步惹的祸。当异步计算<code>cell</code>的布局时，<code>cell</code>使用<code>placeholder</code>占位（通常是白图），布局完成时，才用渲染好的内容填充<code>cell</code>，<code>placeholder</code>到渲染好的内容切换引起闪烁。<code>UITableViewCell</code>因为都是同步，不存在占位图的情况，因此也就不会闪。</p>
<p>先看官方的修改方案，</p>
<pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tableNode</span><span class="hljs-params">(<span class="hljs-number">_</span> tableNode: ASTableNode, nodeForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="hljs-type">ASCellNode</span> &#123;
  <span class="hljs-keyword">let</span> cell = <span class="hljs-type">ASCellNode</span>()
  ... <span class="hljs-comment">// 其他代码</span>
    
  cell.neverShowPlaceholders = <span class="hljs-literal">true</span>
  
  <span class="hljs-keyword">return</span> cell
&#125;</code></pre>
<p>这个方案非常有效，因为设置<code>cell.neverShowPlaceholders = true</code>，会让<code>cell</code>从异步状态衰退回同步状态，若<code>reload</code>某个<code>indexPath</code>的<code>cell</code>，在渲染完成之前，主线程是卡死的，这与<code>UITableView</code>的机制一样，但速度会比<code>UITableView</code>快很多，因为<code>UITableView</code>的布局计算、资源解压、视图合成等都是在主线程进行，而<code>ASTableNode</code>则是多个线程并发进行，何况布局等还有缓存。所以，一般也没有问题，贝聊的聊天界面只是简单这样设置后，就不闪了，而且一帧不掉。但当页面布局较为复杂时，滑动时的卡顿掉帧就变的肉眼可见。</p>
<p>这时，可以设置<code>ASTableNode</code>的<code>leadingScreensForBatching</code>减缓卡顿</p>
<pre><code class="hljs swift"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> &#123;
  <span class="hljs-keyword">super</span>.viewDidLoad()
  ... <span class="hljs-comment">// 其他代码</span>
    
  tableNode.leadingScreensForBatching = <span class="hljs-number">4</span>
&#125;</code></pre>
<p>一般设置<code>tableNode.leadingScreensForBatching = 4</code>即提前计算四个屏幕的内容时，掉帧就很不明显了，典型的空间换时间。但仍不完美，仍然会掉帧，而我们期望的是一帧不掉，如丝般顺滑。这不难，基于上面不闪的方案，刷点小聪明就能解决。</p>
<pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">ASViewController</span> </span>&#123;
  ... <span class="hljs-comment">// 其他代码</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> indexPathesToBeReloaded: [<span class="hljs-type">IndexPath</span>] = []
  
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tableNode</span><span class="hljs-params">(<span class="hljs-number">_</span> tableNode: ASTableNode, nodeForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="hljs-type">ASCellNode</span> &#123;
    <span class="hljs-keyword">let</span> cell = <span class="hljs-type">ASCellNode</span>()
    ... <span class="hljs-comment">// 其他代码</span>
      
    cell.neverShowPlaceholders = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">if</span> indexPathesToBeReloaded.<span class="hljs-built_in">contains</span>(indexPath) &#123;
      <span class="hljs-keyword">let</span> oldCellNode = tableNode.nodeForRow(at: indexPath)
      cell.neverShowPlaceholders = <span class="hljs-literal">true</span>
      oldCellNode?.neverShowPlaceholders = <span class="hljs-literal">true</span>
      <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="hljs-number">0.5</span>, execute: &#123;
        cell.neverShowPlaceholders = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> indexP = <span class="hljs-keyword">self</span>.indexPathesToBeReloaded.index(of: indexPath) &#123;
          <span class="hljs-keyword">self</span>.indexPathesToBeReloaded.remove(at: indexP)
        &#125;
      &#125;)
    &#125;
    <span class="hljs-keyword">return</span> cell
  &#125;
  
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reloadActionHappensHere</span><span class="hljs-params">()</span></span> &#123;
    ... <span class="hljs-comment">// 其他代码</span>
    
    <span class="hljs-keyword">let</span> indexPath = ... <span class="hljs-comment">// 需要roload的indexPath</span>
      indexPathesToBeReloaded.append(indexPath)
    tableNode.reloadRows(at: [indexPath], with: .<span class="hljs-keyword">none</span>)
  &#125;
&#125;</code></pre>
<p>关键代码是，</p>
<pre><code class="hljs swift"><span class="hljs-keyword">if</span> indexPathesToBeReloaded.<span class="hljs-built_in">contains</span>(indexPath) &#123;
  <span class="hljs-keyword">let</span> oldCellNode = tableNode.nodeForRow(at: indexPath)
  cell.neverShowPlaceholders = <span class="hljs-literal">true</span>
  oldCellNode?.neverShowPlaceholders = <span class="hljs-literal">true</span>
  <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="hljs-number">0.5</span>, execute: &#123;
    cell.neverShowPlaceholders = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> indexP = <span class="hljs-keyword">self</span>.indexPathesToBeReloaded.index(of: indexPath) &#123;
      <span class="hljs-keyword">self</span>.indexPathesToBeReloaded.remove(at: indexP)
    &#125;
  &#125;)
&#125;</code></pre>
<p>即，检查当前的<code>indexPath</code>是否被标记，如果是，则先设置<code>cell.neverShowPlaceholders = true</code>，等待<code>reload</code>完成（一帧是1/60秒，这里等待0.5秒，足够渲染了），将<code>cell.neverShowPlaceholders = false</code>。这样<code>reload</code>时既不会闪烁，也不会影响滑动时的异步绘制，因此一帧不掉。</p>
<p>这完全是耍小聪明的做法，但确实非常有效。</p>
<h4 id="3）reloadData时的闪烁"><a href="#3）reloadData时的闪烁" class="headerlink" title="3）reloadData时的闪烁"></a>3）reloadData时的闪烁</h4><p>在下拉刷新后，列表经常需要重新刷新，即调用<code>ASTableNode</code>或者<code>ASCollectionNode</code>的<code>reloadData</code>方法，但会闪，而且很明显。有了单个<code>cell reload</code>时闪烁的解决方案后，此类闪烁解决起来，就很简单了。</p>
<pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reloadDataActionHappensHere</span><span class="hljs-params">()</span></span> &#123;
  ... <span class="hljs-comment">// 其他代码</span>
  
  <span class="hljs-keyword">let</span> <span class="hljs-built_in">count</span> = tableNode.dataSource?.tableNode?(tableNode, numberOfRowsInSection: <span class="hljs-number">0</span>) ?? <span class="hljs-number">0</span>
  <span class="hljs-keyword">if</span> <span class="hljs-built_in">count</span> &gt; <span class="hljs-number">2</span> &#123;
    <span class="hljs-comment">// 将肉眼可见的cell添加进indexPathesToBeReloaded中</span>
    indexPathesToBeReloaded.append(<span class="hljs-type">IndexPath</span>(row: <span class="hljs-number">0</span>, section: <span class="hljs-number">0</span>))
    indexPathesToBeReloaded.append(<span class="hljs-type">IndexPath</span>(row: <span class="hljs-number">1</span>, section: <span class="hljs-number">0</span>))
    indexPathesToBeReloaded.append(<span class="hljs-type">IndexPath</span>(row: <span class="hljs-number">2</span>, section: <span class="hljs-number">0</span>))
  &#125;
  tableNode.reloadData()
    
  ... <span class="hljs-comment">// 其他代码</span>
&#125;</code></pre>
<p>将肉眼可见的<code>cell</code>添加进<code>indexPathesToBeReloaded</code>中即可。</p>
<h4 id="4）insertItems时更改ASCollectionNode的contentOffset引起的闪烁"><a href="#4）insertItems时更改ASCollectionNode的contentOffset引起的闪烁" class="headerlink" title="4）insertItems时更改ASCollectionNode的contentOffset引起的闪烁"></a>4）insertItems时更改ASCollectionNode的contentOffset引起的闪烁</h4><p>我们公司的聊天界面是用<code>AsyncDisplayKit</code>写的，当下拉加载更多新消息时，为保持加载后当前消息的位置不变，需要在<code>collectionNode.insertItems(at: indexPaths)</code>完成后，复原<code>collectionNode.view.contentOffset</code>，代码如下：</p>
<pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertMessagesToTop</span><span class="hljs-params">(indexPathes: [IndexPath])</span></span> &#123;
  <span class="hljs-keyword">let</span> originalContentSizeHeight = collectionNode.view.contentSize.height
  <span class="hljs-keyword">let</span> originalContentOffsetY = collectionNode.view.contentOffset.y
  <span class="hljs-keyword">let</span> heightFromOriginToContentBottom = originalContentSizeHeight - originalContentOffsetY
  <span class="hljs-keyword">let</span> heightFromOriginToContentTop = originalContentOffsetY
  collectionNode.performBatch(animated: <span class="hljs-literal">false</span>, updates: &#123;
    <span class="hljs-keyword">self</span>.collectionNode.insertItems(at: indexPaths)
  &#125;) &#123; (finished) <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">let</span> contentSizeHeight = <span class="hljs-keyword">self</span>.collectionNode.view.contentSize.height
    <span class="hljs-keyword">self</span>.collectionNode.view.contentOffset = <span class="hljs-type">CGPointMake</span>(<span class="hljs-number">0</span>, isLoadingMore ? (contentSizeHeight - heightFromOriginToContentBottom) : heightFromOriginToContentTop)
  &#125;
&#125;</code></pre>
<p>遗憾的是，会闪烁。起初以为是<code>AsyncDisplayKit</code>异步绘制导致的闪烁，一度还想放弃<code>AsyncDisplayKit</code>，用<code>UITableView</code>重写一遍，幸运的是，当时项目工期太紧，没有时间重写，也没时间仔细排查，直接带问题上线了。</p>
<p>最近闲暇，经仔细排查，方知不是<code>AsyncDisplayKit</code>的锅，但也比较难修，有一定的参考价值，因此一并列在这里。</p>
<p>闪烁的原因是，<code>collectionNode insertItems</code>成功后会先绘制<code>contentOffset</code>为<code>CGPoint(x: 0, y: 0)</code>时的一帧画面，无动画时这一帧画面立即显示，然后调用成功回调，回调中复原了<code>collectionNode.view.contentOffset</code>，下一帧就显示复原了位置的画面，前后有变化因此闪烁。这是做消息类APP一并会遇到的bug，google一下，主要有两种解决方案，</p>
<p>第一种，通过仿射变换倒置<code>ASCollectionNode</code>，这样下拉加载更多，就变成正常列表的上拉加载更多，也就无需移动<code>contentOffset</code>。<code>ASCollectionNode</code>还特意设置了个属性<code>inverted</code>，方便大家开发。然而这种方案换汤不换药，当收到新消息，同时正在查看历史消息，依然需要插入新消息并复原<code>contentOffset</code>，闪烁依然在其他情形下发生。</p>
<p>第二种，集成一个<code>UICollectionViewFlowLayout</code>，重写<code>prepare()</code>方法，做相应处理即可。这个方案完美，简介优雅。子类化的<code>CollectionFlowLayout</code>如下：</p>
<pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionFlowLayout</span>: <span class="hljs-title">UICollectionViewFlowLayout</span> </span>&#123;
  <span class="hljs-keyword">var</span> isInsertingToTop = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prepare</span><span class="hljs-params">()</span></span> &#123;
    <span class="hljs-keyword">super</span>.prepare()
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> collectionView = collectionView <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">return</span>
    &#125;
    <span class="hljs-keyword">if</span> !isInsertingToTop &#123;
      <span class="hljs-keyword">return</span>
    &#125;
    <span class="hljs-keyword">let</span> oldSize = collectionView.contentSize
    <span class="hljs-keyword">let</span> newSize = collectionViewContentSize
    <span class="hljs-keyword">let</span> contentOffsetY = collectionView.contentOffset.y + newSize.height - oldSize.height
    collectionView.setContentOffset(<span class="hljs-type">CGPoint</span>(x: collectionView.contentOffset.x, y: contentOffsetY), animated: <span class="hljs-literal">false</span>)
  &#125;
&#125;</code></pre>
<p>当需要<code>insertItems</code>并且保持位置时，将<code>CollectionFlowLayout</code>的<code>isInsertingToTop</code>设置为<code>true</code>即可，完成后再设置为<code>false</code>。如下，</p>
<pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagesViewController</span>: <span class="hljs-title">ASViewController</span> </span>&#123;
  ... <span class="hljs-comment">// 其他代码</span>
  <span class="hljs-keyword">var</span> collectionNode: <span class="hljs-type">ASCollectionNode!</span>
  <span class="hljs-keyword">var</span> flowLayout: <span class="hljs-type">CollectionFlowLayout!</span>
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> &#123;
    <span class="hljs-keyword">super</span>.viewDidLoad()
    flowLayout = <span class="hljs-type">CollectionFlowLayout</span>()
    collectionNode = <span class="hljs-type">ASCollectionNode</span>(collectionViewLayout: flowLayout)
    ... <span class="hljs-comment">// 其他代码</span>
  &#125;
  
  ... <span class="hljs-comment">// 其他代码</span>
  
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertMessagesToTop</span><span class="hljs-params">(indexPathes: [IndexPath])</span></span> &#123;
    flowLayout.isInsertingToTop = <span class="hljs-literal">true</span>
    collectionNode.performBatch(animated: <span class="hljs-literal">false</span>, updates: &#123;
      <span class="hljs-keyword">self</span>.collectionNode.insertItems(at: indexPaths)
    &#125;) &#123; (finished) <span class="hljs-keyword">in</span>
      <span class="hljs-keyword">self</span>.flowLayout.isInsertingToTop = <span class="hljs-literal">false</span>
    &#125;
  &#125;
  
  ... <span class="hljs-comment">// 其他代码</span>
&#125;</code></pre>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p><code>AsyncDisplayKit</code>采用的是<code>flexbox</code>的布局思想，非常高效直观简洁，但毕竟迥异于<code>AutoLayout</code>和<code>frame layout</code>的布局风格，咋一上手，很不习惯，有些小技巧还是需要慢慢积累，有些概念也需要逐渐熟悉深入，下面列举几个笔者觉得比较重要的概念</p>
<h4 id="1）设置任意间距"><a href="#1）设置任意间距" class="headerlink" title="1）设置任意间距"></a>1）设置任意间距</h4><p><code>AutoLayout</code>实现任意间距，比较容易直观，因为<code>AutoLayout</code>的约束，本来就是我的边离你的边有多远的概念，而<code>AsyncDisplayKit</code>并没有，<code>AsyncDisplayKit</code>里面的概念是，我自己的前面有多少空白距离，我自己的后面有多少空白距离，更强调自己。假如有三个元素，怎么约束它们之间的间距？</p>
<p><code>AutoLayout</code>是这样的：</p>
<pre><code class="hljs swift"><span class="hljs-keyword">import</span> Masonry
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeView</span>: <span class="hljs-title">UIView</span> </span>&#123;
  <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>() &#123;
    <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()
    <span class="hljs-keyword">let</span> viewA = <span class="hljs-type">UIView</span>()
    <span class="hljs-keyword">let</span> viewB = <span class="hljs-type">UIView</span>()
    <span class="hljs-keyword">let</span> viewC = <span class="hljs-type">UIView</span>()
    addSubview(viewA)
    addSubview(viewB)
    addSubview(viewC)
    
    viewB.snp.makeConstraints &#123; (make) <span class="hljs-keyword">in</span>
      make.<span class="hljs-keyword">left</span>.equalTo(viewA.snp.<span class="hljs-keyword">right</span>).offset(<span class="hljs-number">15</span>)
    &#125;
    
    viewC.snp.makeConstraints &#123; (make) <span class="hljs-keyword">in</span>
      make.<span class="hljs-keyword">left</span>.equalTo(viewB.snp.<span class="hljs-keyword">right</span>).offset(<span class="hljs-number">5</span>)
    &#125;
  &#125;
&#125;</code></pre>
<p>而<code>AsyncDisplayKit</code>是这样的：</p>
<pre><code class="hljs swift"><span class="hljs-keyword">import</span> AsyncDisplayKit
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeNode</span>: <span class="hljs-title">ASDisplayNode</span> </span>&#123;
  <span class="hljs-keyword">let</span> nodeA = <span class="hljs-type">ASDisplayNode</span>()
  <span class="hljs-keyword">let</span> nodeB = <span class="hljs-type">ASDisplayNode</span>()
  <span class="hljs-keyword">let</span> nodeC = <span class="hljs-type">ASDisplayNode</span>()
  <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>() &#123;
    <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()
    addSubnode(nodeA)
    addSubnode(nodeB)
    addSubnode(nodeC)
  &#125;
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">layoutSpecThatFits</span><span class="hljs-params">(<span class="hljs-number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="hljs-type">ASLayoutSpec</span> &#123;
    nodeB.style.spaceBefore = <span class="hljs-number">15</span>
    nodeC.stlye.spaceBefore = <span class="hljs-number">5</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-type">ASStackLayoutSpec</span>(direction: .horizontal, spacing: <span class="hljs-number">0</span>, justifyContent: .start, alignItems: .start, children: [nodeA, nodeB, nodeC])
  &#125;
&#125;</code></pre>
<p>如果是拿<code>ASStackLayoutSpec</code>布局，元素之间的任意间距一般是通过元素自己的<code>spaceBefore</code>或者<code>spaceBefore style</code>实现，这是自我包裹性，更容易理解，如果不是拿<code>ASStackLayoutSpec</code>布局，可以将某个元素包裹成<code>ASInsetsLayoutSpec</code>，再设置<code>UIEdgesInsets</code>，保持自己的四周任意边距。</p>
<p>能任意设置间距是自由布局的基础。</p>
<h4 id="2）flexGrow和flexShrink"><a href="#2）flexGrow和flexShrink" class="headerlink" title="2）flexGrow和flexShrink"></a>2）flexGrow和flexShrink</h4><p><code>flexGrow</code>和<code>flexShrink</code>是相当重要的概念，<code>flexGrow</code>是指当有多余空间时，拉伸谁以及相应的拉伸比例（当有多个元素设置了<code>flexGrow</code>时），<code>flexShrink</code>相反，是指当空间不够时，压缩谁及相应的压缩比例（当有多个元素设置了<code>flexShrink</code>时）。<br>灵活使用<code>flexGrow</code>和<code>spacer</code>(占位<code>ASLayoutSpec</code>)可以实现很多效果，比如等间距，<br><img src="/images/equalspace.png" alt=""></p>
<p>实现代码如下，</p>
<pre><code class="hljs swift"><span class="hljs-keyword">import</span> AsyncDisplayKit
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContainerNode</span>: <span class="hljs-title">ASDisplayNode</span> </span>&#123;
  <span class="hljs-keyword">let</span> nodeA = <span class="hljs-type">ASDisplayNode</span>()
  <span class="hljs-keyword">let</span> nodeB = <span class="hljs-type">ASDisplayNode</span>()
  <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>() &#123;
    <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()
    addSubnode(nodeA)
    addSubnode(nodeB)
  &#125;
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">layoutSpecThatFits</span><span class="hljs-params">(<span class="hljs-number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="hljs-type">ASLayoutSpec</span> &#123;
    <span class="hljs-keyword">let</span> spacer1 = <span class="hljs-type">ASLayoutSpec</span>()
    <span class="hljs-keyword">let</span> spacer2 = <span class="hljs-type">ASLayoutSpec</span>()
    <span class="hljs-keyword">let</span> spacer3 = <span class="hljs-type">ASLayoutSpec</span>()
    spacer1.stlye.flexGrow = <span class="hljs-number">1</span>
    spacer2.stlye.flexGrow = <span class="hljs-number">1</span>
    spacer3.stlye.flexGrow = <span class="hljs-number">1</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-type">ASStackLayoutSpec</span>(direction: .horizontal, spacing: <span class="hljs-number">0</span>, justifyContent: .start, alignItems: .start, children: [spacer1, nodeA,spacer2, nodeB, spacer3])
  &#125;
&#125;</code></pre>
<p>如果<code>spacer</code>的<code>flexGrow</code>不同就可以实现指定比例的布局，再结合<code>width</code>样式，轻松实现以下布局<br><img src="/images/complexspace.png" alt=""></p>
<p>布局代码如下，</p>
<pre><code class="hljs swift"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">layoutSpecThatFits</span><span class="hljs-params">(<span class="hljs-number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="hljs-type">ASLayoutSpec</span> &#123;
  <span class="hljs-keyword">let</span> spacer1 = <span class="hljs-type">ASLayoutSpec</span>()
  <span class="hljs-keyword">let</span> spacer2 = <span class="hljs-type">ASLayoutSpec</span>()
  <span class="hljs-keyword">let</span> spacer3 = <span class="hljs-type">ASLayoutSpec</span>()
  spacer1.stlye.flexGrow = <span class="hljs-number">2</span>
  spacer2.stlye.width = <span class="hljs-type">ASDimensionMake</span>(<span class="hljs-number">100</span>)
  spacer3.stlye.flexGrow = <span class="hljs-number">1</span>
  
  <span class="hljs-keyword">return</span> <span class="hljs-type">ASStackLayoutSpec</span>(direction: .horizontal, spacing: <span class="hljs-number">0</span>, justifyContent: .start, alignItems: .start, children: [spacer1, nodeA,spacer2, nodeB, spacer3])
&#125;</code></pre>
<p>相同的布局如果用<code>Autolayout</code>，麻烦去了。</p>
<h4 id="3）constrainedSize的理解"><a href="#3）constrainedSize的理解" class="headerlink" title="3）constrainedSize的理解"></a>3）constrainedSize的理解</h4><p><code>constrainedSize</code>是指某个<code>node</code>的大小取值范围，有<code>minSize</code>和<code>maxSize</code>两个属性。比如下图的布局：<br><img src="/images/complexlayout.png" alt=""></p>
<pre><code class="hljs swift"><span class="hljs-keyword">import</span> AsyncDisplayKit
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContainerNode</span>: <span class="hljs-title">ASDisplayNode</span> </span>&#123;
  <span class="hljs-keyword">let</span> nodeA = <span class="hljs-type">ASDisplayNode</span>()
  <span class="hljs-keyword">let</span> nodeB = <span class="hljs-type">ASDisplayNode</span>()
  <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>() &#123;
    <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()
    addSubnode(nodeA)
    addSubnode(nodeB)
    nodeA.style.preferredSize = <span class="hljs-type">CGSize</span>(width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span>)
  &#125;

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">layoutSpecThatFits</span><span class="hljs-params">(<span class="hljs-number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="hljs-type">ASLayoutSpec</span> &#123;
    nodeB.style.flexShrink = <span class="hljs-number">1</span>
    nodeB.style.flexGrow = <span class="hljs-number">1</span>
    <span class="hljs-keyword">let</span> stack = <span class="hljs-type">ASStackLayoutSpec</span>(direction: .horizontal, spacing: e, justifyContent: .start, alignItems: .start, children: [nodeA, nodeB])
    <span class="hljs-keyword">return</span> <span class="hljs-type">ASInsetLayoutSpec</span>(insets: <span class="hljs-type">UIEdgeInsetsMake</span>(a, b, <span class="hljs-built_in">c</span>, d), child: stack)
  &#125;
&#125;</code></pre>
<p>其中方法<code>override func layoutSpecThatFits(_ constrainedSize: ASSizeRange) -&gt; ASLayoutSpec</code>中的<code>constrainedSize</code>所指是<code>ContainerNode</code>自身大小的取值范围。给定<code>constrainedSize</code>，<code>AsyncDisplayKit</code>会根据<code>ContainerNode</code>在<code>layoutSpecThatFits(_:)</code>中施加在<code>nodeA、nodeB</code>的布局规则和<code>nodeA、nodeB</code>自身属性计算<code>nodeA、nodeB</code>的<code>constrainedSize</code>。</p>
<p>假如<code>constrainedSize</code>的<code>minSize</code>是<code>CGSize(width: 0, height: 0)</code>，<code>maxSize</code>为<code>CGSize(width: 375, height: Inf+)</code>(<code>Inf+</code>为正无限大)，则：</p>
<p>1）根据布局规则和<code>nodeA</code>自身样式属性<code>maxWidth</code>、<code>minWidth</code>、<code>width</code>、<code>height</code>、<code>preferredSize</code>，可计算出<code>nodeA</code>的<code>constrainedSize</code>的<code>minSize</code>和<code>maxSize</code>均为其<code>preferredSize</code>即<code>CGSize(width: 100, height: 100)</code>，因为布局规则为水平向的<code>ASStackLayout</code>，当空间富余或者空间不足时，<code>nodeA</code>即不压缩又不拉伸，所以会取其指定的<code>preferredSize</code>。</p>
<p>2）根据布局规则和<code>nodeB</code>自身样式属性<code>maxWidth</code>、<code>minWidth</code>、<code>width</code>、<code>height</code>、<code>preferredSize</code>，可以计算出其<code>constrainedSize</code>的<code>minSize</code>是<code>CGSize(width: 0, height: 0)</code>，<code>maxSize</code>为<code>CGSize(width: 375 - 100 - b - e - d, height: Inf+)</code>，因为<code>nodeB</code>的<code>flexShrink</code>和<code>flexGrow</code>均为1，也即当空间富余或者空间不足时，<code>nodeB</code>添满富余空间或压缩至空间够为止。</p>
<p>如果不指定<code>nodeB</code>的<code>flexShrink</code>和<code>flexGrow</code>，那么当空间富余或者空间不足时，<code>AsyncDisplayKit</code>就不知道压缩和拉伸哪一个布局元素，则<code>nodeB</code>的<code>constrainedSize</code>的<code>maxSize</code>就变为<code>CGSize(width: Inf+, height: Inf+)</code>，即完全无大小限制，可想而知，<code>nodeB</code>的子<code>node</code>的布局将完全不对。这也说明另外一个问题，<code>node</code>的<code>constrainedSize</code>并不是一定大于其子<code>node</code>的<code>constrainedSize</code>。</p>
<p>理解<code>constrainedSize</code>的计算，才能熟练利用<code>node</code>的样式<code>maxWidth</code>、<code>minWidth</code>、<code>width</code>、<code>height</code>、<code>preferredSize</code>、<code>flexShrink</code>和<code>flexGrow</code>进行布局。如果发现布局结果不对，而对应<code>node</code>的布局代码确是正确无误，一般极有可能是因为此<code>node</code>的父布局元素不正确。</p>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>因为<code>AsyncDisplayKit</code>的布局方式有两种，<code>frame</code>布局和<code>flexbox</code>式的布局，相应的动画方式也有两种</p>
<h4 id="1）frame布局"><a href="#1）frame布局" class="headerlink" title="1）frame布局"></a>1）frame布局</h4><p>如果采用的是<code>frame</code>布局，动画跟普通的<code>UIView</code>相同</p>
<pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">ASViewController</span> </span>&#123;
  <span class="hljs-keyword">let</span> nodeA = <span class="hljs-type">ASDisplayNode</span>()
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> &#123;
    <span class="hljs-keyword">super</span>.viewDidLoad()
    nodeA.frame = <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>, width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span>)
    ... <span class="hljs-comment">// 其他代码</span>
  &#125;

  ... <span class="hljs-comment">// 其他代码</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">animateNodeA</span><span class="hljs-params">()</span></span> &#123;
    <span class="hljs-type">UIView</span>.animate(withDuration: <span class="hljs-number">0.5</span>) &#123; 
      <span class="hljs-keyword">let</span> newFrame = ... <span class="hljs-comment">// 新的frame</span>
      nodeA.frame = newFrame
    &#125;
  &#125;
&#125;</code></pre>
<p>不要觉得用了<code>AsyncDisplayKit</code>就告别了<code>frame</code>布局，<code>ViewController</code>中主要元素个数很少，布局简单，因此，一般也还是采用<code>frame layout</code>，如果只是做一些简单的动画，直接采用<code>UIView</code>的动画<code>API</code>即可</p>
<h4 id="2）flexbox式的布局"><a href="#2）flexbox式的布局" class="headerlink" title="2）flexbox式的布局"></a>2）flexbox式的布局</h4><p>这种布局方式，是在某个子<code>node</code>中常用的，如果<code>node</code>内部布局发生了变化，又需要做动画时，就需要复写<code>AsyncDisplayKit</code>的动画<code>API</code>，并基于提供的动画上下文类<code>context</code>，做动画：</p>
<pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeNode</span>: <span class="hljs-title">ASDisplayNode</span> </span>&#123;
  <span class="hljs-keyword">let</span> nodeA = <span class="hljs-type">ASDisplayNode</span>()

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">animateLayoutTransition</span><span class="hljs-params">(<span class="hljs-number">_</span> context: ASContextTransitioning)</span></span> &#123;
    <span class="hljs-comment">// 利用context可以获取animate前后布局信息</span>

    <span class="hljs-type">UIView</span>.animate(withDuration: <span class="hljs-number">0.5</span>) &#123; 
      <span class="hljs-comment">// 不使用系统默认的fade动画，采用自定义动画</span>
      <span class="hljs-keyword">let</span> newFrame = ... <span class="hljs-comment">// 新的frame</span>
      nodeA.frame = newFrame
    &#125;
  &#125;
&#125;</code></pre>
<p>系统默认的动画是渐隐渐显，可以获取<code>animate</code>前后布局信息，比如某个子<code>node</code>两种布局中的<code>frame</code>，然后再自定义动画类型。如果想触发动画，主动调用<code>SomeNode</code>的触发方法<code>transitionLayout(withAnimation:shouldMeasureAsync:measurementCompletion:)</code>即可。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>为了方便将一个<code>UIView</code>或者<code>CALayer</code>转化为一个<code>ASDisplayNode</code>，系统提供了用<code>block</code>初始化<code>ASDisplayNode</code>的简便方法：</p>
<pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">convenience</span> <span class="hljs-keyword">init</span>(viewBlock: @escaping <span class="hljs-type">AsyncDisplayKit</span>.<span class="hljs-type">ASDisplayNodeViewBlock</span>)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">convenience</span> <span class="hljs-keyword">init</span>(viewBlock: @escaping <span class="hljs-type">AsyncDisplayKit</span>.<span class="hljs-type">ASDisplayNodeViewBlock</span>, didLoad didLoadBlock: <span class="hljs-type">AsyncDisplayKit</span>.<span class="hljs-type">ASDisplayNodeDidLoadBlock?</span> = <span class="hljs-literal">nil</span>)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">convenience</span> <span class="hljs-keyword">init</span>(layerBlock: @escaping <span class="hljs-type">AsyncDisplayKit</span>.<span class="hljs-type">ASDisplayNodeLayerBlock</span>)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">convenience</span> <span class="hljs-keyword">init</span>(layerBlock: @escaping <span class="hljs-type">AsyncDisplayKit</span>.<span class="hljs-type">ASDisplayNodeLayerBlock</span>, didLoad didLoadBlock: <span class="hljs-type">AsyncDisplayKit</span>.<span class="hljs-type">ASDisplayNodeDidLoadBlock?</span> = <span class="hljs-literal">nil</span>)</code></pre>
<p>需要注意的是所传入的<code>block</code>会被要创建的<code>node</code>持有。如果<code>block</code>中反过来持有了这个<code>node</code>的持有者，则会产生循环引用，导致内存泄漏：<br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeNode</span> </span>&#123;
  <span class="hljs-keyword">var</span> nodeA: <span class="hljs-type">ASDisplayNode!</span>
  <span class="hljs-keyword">let</span> color = <span class="hljs-type">UIColor</span>.red
  <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>() &#123;
    <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()
    nodeA = <span class="hljs-type">ASDisplayNode</span> &#123;
      <span class="hljs-keyword">let</span> view = <span class="hljs-type">UIView</span>()
      view.backgroundColor = <span class="hljs-keyword">self</span>.color <span class="hljs-comment">// 内存泄漏</span>
      <span class="hljs-keyword">return</span> view
    &#125;
  &#125;
&#125;</code></pre></p>
<h2 id="子线程崩溃"><a href="#子线程崩溃" class="headerlink" title="子线程崩溃"></a>子线程崩溃</h2><p><code>AsyncDisplayKit</code>的性能优势来源于异步绘制，异步的意思是有时候<code>node</code>会在子线程创建，如果继承了一个<code>ASDisplayNode</code>，一不小心在初始化时调用了<code>UIKit</code>的相关方法，则会出现子线程崩溃。比如以下<code>node</code>，<br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeNode</span> </span>&#123;
  <span class="hljs-keyword">let</span> iconImageNode: <span class="hljs-type">ASDisplayNode</span>
  <span class="hljs-keyword">let</span> color = <span class="hljs-type">UIColor</span>.red
  <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>() &#123;
    iconImageNode = <span class="hljs-type">ASImageNode</span>()
    iconImageNode.image = <span class="hljs-type">UIImage</span>(named: <span class="hljs-string">"iconName"</span>) <span class="hljs-comment">// 需注意SomeNode有时会在子线程初始化，而UIImage(named:)并不是线程安全</span>

    <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()

  &#125;
&#125;</code></pre></p>
<p>但在<code>node</code>初始化时调用<code>UIImage(named:)</code>创建图片是不可避免的，用<code>methodSwizzle</code>将<code>UIImage(named:)</code>置换成安全的即可。</p>
<p>其实在子线程初始化<code>node</code>并不多见，一般都在主线程。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一年的实践下来，闪烁是<code>AsyncDisplayKit</code>遇到的最大的问题，修复起来也颇为费神。其他bug，有时虽然很让人头疼，但由于<code>AsyncDisplayKit</code>是对UIKit的再封装，实在不行，仍然可以越过<code>AsyncDisplayKit</code>用<code>UIKit</code>的方法修复。</p>
<p>学习曲线也不算很陡峭。</p>
<p>考虑到<code>AsyncDisplayKit</code>的种种好处，非常推荐<code>AsyncDisplayKit</code>，当然还是仅限于用在比较复杂和动态的页面中。</p>

        </div>
        
        <div class="level is-size-7 is-uppercase">
            <div class="level-start">
                <div class="level-item">
                    <span class="is-size-6 has-text-grey has-mr-7">#</span>
                    <a class="has-link-grey -link" href="/tags/iOS/" rel="tag">iOS</a>
                </div>
            </div>
        </div>
        
        
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3>
        <div class="buttons is-centered">
            
                
<a class="button is-success donate">
    <span class="icon is-small">
        <i class="fab fa-weixin"></i>
    </span>
    <span>微信</span>
    <div class="qrcode"><img src="/images/wechat_pay.jpg" alt="微信"></div>
</a>

                
        </div>
    </div>
</div>



<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        <div class="level-start">
            <a class="level level-item has-link-grey  article-nav-prev" href="/2020/02/10/adaboost/">
                <i class="level-item fas fa-chevron-left"></i>
                <span class="level-item">从一个demo学习AdaBoost</span>
            </a>
        </div>
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/2017/04/08/sharecode/">
                <span class="level-item">iOS两个客户端代码复用小技巧</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>


</div>
                
                




<div
    class="column is-3-tablet is-3-desktop is-3-widescreen  has-order-3 column-right ">
    
    <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            链接
        </h3>
        <ul class="menu-list">
        
            <li>
                <a class="level is-mobile" href="https://weibo.com/shellhue" target="_blank" rel="noopener">
                    <span class="level-left">
                        <span class="level-item">我的微博</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">weibo.com</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="https://www.zhihu.com/people/huang-ze-yu-51-15" target="_blank" rel="noopener">
                    <span class="level-left">
                        <span class="level-item">我的专栏</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">www.zhihu.com</span>
                    </span>
                </a>
            </li>
        
        </ul>
        </div>
    </div>
</div>

    
    <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            最新文章
        </h3>
        
        <article class="media">
            
            <a href="/2020/06/15/fpn/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/fpn_1.png" alt="一文看尽物体检测中的各种FPN">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-06-15T15:35:29.000Z">2020-06-15</time></div>
                    <a href="/2020/06/15/fpn/" class="title has-link-black-ter is-size-6 has-text-weight-normal">一文看尽物体检测中的各种FPN</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/06/13/workonce/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/workonce_1.jpg" alt="一劳永逸的财富观">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-06-12T16:02:23.000Z">2020-06-13</time></div>
                    <a href="/2020/06/13/workonce/" class="title has-link-black-ter is-size-6 has-text-weight-normal">一劳永逸的财富观</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/06/07/aitop/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/deep_learning_floor.jpg" alt="当前深度学习算法工程师的职业天花板">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-06-07T14:35:29.000Z">2020-06-07</time></div>
                    <a href="/2020/06/07/aitop/" class="title has-link-black-ter is-size-6 has-text-weight-normal">当前深度学习算法工程师的职业天花板</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/05/10/investment/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/investment_1.jpg" alt="要做短线投机之前，先做一个简单的数学题">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-05-10T15:35:29.000Z">2020-05-10</time></div>
                    <a href="/2020/05/10/investment/" class="title has-link-black-ter is-size-6 has-text-weight-normal">要做短线投机之前，先做一个简单的数学题</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/04/28/efficientnet/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/efficientnet_1.png" alt="细说EfficientNet">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-04-28T15:35:29.000Z">2020-04-28</time></div>
                    <a href="/2020/04/28/efficientnet/" class="title has-link-black-ter is-size-6 has-text-weight-normal">细说EfficientNet</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
    
    <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                标签
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Machine-Learning/">
                        <span class="tag">Machine Learning</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/design-pattern/">
                        <span class="tag">design pattern</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/git/">
                        <span class="tag">git</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/iOS/">
                        <span class="tag">iOS</span>
                        <span class="tag is-grey">9</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/leetcode/">
                        <span class="tag">leetcode</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">
                        <span class="tag">人工智能</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/%E5%B0%8F%E7%BA%B8%E5%B1%91/">
                        <span class="tag">小纸屑</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/%E6%84%9F%E6%82%9F/">
                        <span class="tag">感悟</span>
                        <span class="tag is-grey">5</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/%E6%85%A2%E6%8A%95%E8%B5%84/">
                        <span class="tag">慢投资</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/%E7%89%A9%E4%BD%93%E6%A3%80%E6%B5%8B/">
                        <span class="tag">物体检测</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
    
    
</div>

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/../images/logo.png" alt="AsyncDisplayKit近一年的使用体会及疑难点" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2020 轻墨&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a>
                
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>


<script>
var IcarusThemeSettings = {
    site: {
        url: 'http://yoursite.com',
        external_link: {"enable":true,"exclude":[]}
    },
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>





<script src="/js/animation.js"></script>



<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
<script src="/js/gallery.js" defer></script>



<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>


<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>














<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

</html>