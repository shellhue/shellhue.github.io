{"pages":[{"title":"关于","text":"我是轻墨，毕业于北京航空航天大学，曾长时间研究学习土木工程专业，机缘巧合，误入编程这行，现在主要学习iOS开发，至今跟大多数人一样，未有任何作品上线。 轻墨是我的个人博客，主要记录我所有感悟。 Everyone is born with a destiny！ ——-《lost》 Get busy living, or get busy dying. ——《The Shawshank Redemption》 我最喜欢上面两句话，我相信人来到人世间，所肩负的使命，是在自己最喜欢的事上，倾尽全力。 我的学习路线 C语言（2008.09） Java（2013.07-2013.08） PHP、HTML、CSS、JavaScript（2015.03-2015.06） Swift（2015.06-至今） Objective-C(2016.06.20-至今) React and React Native（2016.03-至今） 寄语人生路漫漫，愿沿途烟花璀璨。","link":"/about/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"iOS触摸事件的流动","text":"当指肚轻触屏幕，整个系统像沉睡的生灵突然被惊醒，然后经历过腥风血雨的一段奇幻旅行，最终又归于沉寂。 整个iOS触摸事件从产生到寂灭大致如下图： 起始阶段——&gt; cpu处于睡眠状态，等待事件发生——&gt; 手指触摸屏幕 系统响应阶段——&gt; 屏幕硬件感应到输入，并将感应到的事件传递给输入输出驱动IOKit——&gt; IOKit.framework封装整个触摸事件为IOHIDEvent对象——&gt; IOKit.framework通过IPC将事件转发给SpringBoard.app 以上是系统层的响应。系统感应到外界的输入，并将相应的输入封装成比较概括的IOHIDEvent对象，然后UIKit通过IOHIDEvent的类型，判断出相应事件应该由SpringBoard .app处理，直接通过mach port(IPC进程间通信)转发给SpringBoard.app。 SpringBoard.app就是iOS的系统桌面，当触摸事件发生时，也只有负责管理桌面的SpringBoard.app才知道如何正确的响应。因为触摸发生时，有可能用户正在桌面翻页找App，也有可能正处于在微信中刷朋友圈。 桌面响应阶段——&gt; SpringBoard.app主线程Runloop收到IOKit.framework转发来的消息苏醒，并触发对应Mach Port的Source1回调__IOHIDEventSystemClientQueueCallback()。 ——&gt; 如果SpringBoard.app监测到有App在前台（记为xxxx.app），SpringBoard.app通过mach port(IPC进程间通信)转发给xxxx.app，如果SpringBoard.app监测到监测无前台App，则SpringBoard.app进入App内部响应阶段的第二段，记触发Source0回调。 App内部响应阶段——&gt; 前台App主线程Runloop收到SpringBoard.app转发来的消息苏醒，并触发对应Mach Port的Source1回调__IOHIDEventSystemClientQueueCallback()。——&gt; Source1回调内部触发Source0回调__UIApplicationHandleEventQueue()——&gt; Soucre0回调内部，封装IOHIDEvent为UIEvent——&gt; Soucre0回调内部调用UIApplication的sendEvent:方法，将UIEvent传给UIWindow——&gt; 平时开发熟悉的触摸事件响应链从这开始了——&gt; 通过递归调用UIView层级的hitTest(_:with:)，结合point(inside:with:)找到UIEvent中每一个UITouch所属的UIView（其实是想找到离触摸事件点最近的那个UIView）。这个过程是从UIView层级的最顶层往最底层递归查询，但这不是UIResponder响应链，事件响应是在UIEvent中每一个UITouch所属的UIView都确定之后方才开始。 但需要注意，以下三种情况UIView的hitTest(_:with:)不会被调用，也导致其子UIView的hitTest(_:with:)不会被调用，而之后响应事件是下向上传递的，这直接导致以下三种情况的UIView及其子UIView不接收任何触摸事件： userInteractionEnabled = NO hidden = YES alpha = 0.0~0.01之间 提示: UIImageView的userInteractionEnabled默认为NO,因此UIImageView以及它的子控件默认是不接收触摸事件的。 当把断点打在某个UIViewhitTest(_:with:)中时，对应的调用堆栈如下：——&gt; 根据围绕UITouch所属的UIView及其祖先UIView的gesture recognizers，来确定一个UITouch的gestureRecognizers ——&gt; UITouch所属的UIView和gestureRecognizers收到此UITouch和相应的UIEvent，并按照UITouch所处的状态调用四大UITouch方法touchesBegan(_:with:) touchesMoved(_:with:) touchesEnded(_:with:) touchesCancelled(_:with:)中的一个。（事件响应开始） ——&gt; 对于UIView收到的UITouches事件（四大UITouch事件都是如此），则会按照UIResponder响应链一直往上传递，直到某个UIResponder因为主动响应触摸事件，切断了响应链（即不调用下一个UIResponder的响应方法），如果一直没有UIResponder做响应处理，则这些UITouches到达最后的响应者即UIApplication后，就被吃掉了，消失了。 ——&gt; 如果在事件响应过程中，有UIGestureRecognizer成功识别，则此UIGestureRecognizer将独自占有所需要的UITouches，这些UITouches所属的UIView及其他的UIGestureRecognizer的touchesCancelled(_:with:)方法将调用（如果在手势的代理中设置可以同时识别两个手势，则允许同时识别的手势均可以收到所需要的UITouches事件）。但与识别成功的UIGestureRecognizer无关的UITouches则会继续按照上述传递逻辑传递。也即允许两个手势同时识别，只要所占有的UITouches不相同。 ——&gt; 如果UIGestureRecognizer识别成功，则调用相应的action，处理对应的逻辑。如果某个UIResponder主动响应了触摸事件，则根据其本身的响应逻辑处理对应的业务，UIControl都是主动响应并切断UITouch的向上传递的。 ——&gt; UITouches事件流动完毕，整个系统重新进入睡眠等待下一个事件 总结从手指触碰到屏幕，UITouch大致经历三个阶段，系统处理阶段----&gt;SpringBoard.app处理阶段----&gt;前台App处理阶段，事实上日常开发只需知晓最后一个阶段即可，前两个阶段参考资料也不多，更多的还涉及系统底层，这里仅做简单介绍。 参考文献： 《iOS 事件处理机制与图像渲染过程》 Event Handling Guide for iOS IOHIDFamily SpringBoard 深入理解RunLoop Programming iOS 9 GSEvent 事件传递 iOS事件点击之发生了什么？ IOKit.framework","link":"/2017/03/04/FlowOfUITouch/"},{"title":"AsyncDisplayKit近一年的使用体会及疑难点","text":"一个第三方库能做到像新产品一样，值得大家去写写使用体会的，并不多见，AsyncDisplayKit却完全可以，因为AsyncDisplayKit不仅仅是一个工具，它更像一个系统UI框架，改变整个编码体验。也正是这种极强的侵入性，导致不少听过、star过，甚至下过demo跑过AsyncDisplayKit的你我，望而却步，驻足观望。但列表界面稍微复杂时，烦人的高度计算，因为性能不得不放弃Autolayout而选择上古时代的frame layout，令人精疲力尽，这时AsyncDisplayKit总会不自然浮现眼前，让你跃跃欲试。 去年10月份，我们入坑了。$\\Omega(f) = \\gamma T + \\frac{1}{2} \\lambda \\parallel w \\parallel ^2 \\tag{3}$${\\sum_{i} l(\\hat{y}_i, y_i)}$ L^{(t)} \\simeq \\sum_{i}^{n} \\left [ \\color{red}{l(y_{i}, \\hat{y_i}^{(t-1)}) + g_i \\ f_t(X_i) + h_i \\ f_t^2(X_i))} \\right ] + \\Omega(f_t) \\tag{5}\\label{5}\\begin{aligned} \\hat{L}^{(t)} &= \\underbrace{\\sum_{i}^{n} \\left [ g_i \\ f_t(X_i) + h_i \\ f_t^2(X_i)) \\right ]}_{对样本进行积累} + \\color{red}{ \\gamma T + \\frac{1}{2} \\lambda \\underbrace{\\sum_{j=1}^{T} \\parallel w_j \\parallel ^2}_{对叶子节点进行积累}} \\\\ &= \\sum_{i}^{n} \\left [ g_i \\ \\color{blue}{w_{q(X_i)}} + h_i \\color{blue}{\\ w_{q(X_i)}^2} \\right ] + \\gamma T + \\frac{1}{2} \\lambda \\sum_{j=1}^{T} \\parallel w_j \\parallel ^2 \\\\ &= \\sum_{j=1}^{T}\\left[ (\\sum_{i \\in I_j} g_i) w_j + \\frac{1}{2} (\\sum_{i\\in I_{j}} h_i + \\lambda ) w_j^2 \\right] + \\gamma T \\end{aligned} \\tag{7}\\label{7}当时还只是拿简单的列表页试水，基本上手后，去年底在稍微空闲的时候用AsyncDisplayKit重构了帖子详情，今年三月份，又借着公司聊天增加群聊的契机，用AsyncDisplayKit重构整个聊天。林林总总，从简单到复杂，踩过的坑大大小小，将近一年的时光转眼飞逝，可以写写总结了。 学习曲线先说说学习曲线，这是大家都比较关心的问题。跟大多人一样，一开始我以为AsyncDisplayKit会像Rxswift等MVVM框架一样，有着陡峭的学习曲线。但事实上，AsyncDisplayKit的学习曲线还算平滑。 主要是因为AsyncDisplayKit只是对UIKit的再一次封装，基本沿用了UIKit的API设计，大部分情况下，只是将view改成node，UI前缀改为AS，写着写着，恍惚间，你以为自己还是在写UIKit呢。 比如ASDisplayNode与UIView：let nodeA = ASDisplayNode()let nodeB = ASDisplayNode()let nodeC = ASDisplayNode()nodeA.addSubnode(nodeB)nodeA.addSubnode(nodeC)nodeA.backgroundColor = .rednodeA.frame = CGRect(x: 0, y: 0, width: 100, height: 100)nodeC.removeFromSupernode()let viewA = UIView()let viewB = UIView()let viewC = UIView()viewA.addSubview(viewB)viewA.addSubview(viewC)viewA.backgroundColor = .redviewA.frame = CGRect(x: 0, y: 0, width: 100, height: 100)viewC.removeFromSuperview()相信你看两眼也就摸出门道了，大部分API一模一样。 真正发生翻天覆地变化的是布局方式，AsyncDisplayKit用的是flexbox布局，UIView使用的是Autolayout。用AsyncDisplayKit的flexbox布局替代Autolayout布局，完全不亚于用Autolayout替换frame布局的蜕变，需要比较大的观念转变。 但flexbox布局被提出已久，且其本身直观简单，较容易上手，学习曲线只是略陡峭。 这里有一个学习AsyncDisplayKit布局的小游戏，简单有趣，可以一玩。 整体上两天即可上手，无须担心学习曲线问题。 体会当过了上手的艰难阶段后，才是真正开始体会AsyncDisplayKit的时候。用了将近一年，有几点AsyncDisplayKit的优势相当明显： 1）cell中再也不用算高度和位置等frame信息了这是非常非常非常非常诱人的，当cell中有动态文本时，文本的高度计算很费神，计算完，还得缓存，如果再加上其他动态内容，比如有时候没图片，那frame算起来，简直让人想哭，而如果用AsyncDisplayKit，所有的height、frame计算都烟消云散，甚至都不知道frame这个东西存在过，很酸爽。 2）一帧不掉平时界面稍微动态点，元素稍微多点，Autolayout的性能就不堪重用，而上古时代的frame布局在高效缓存的基础上确实可以做到高性能，但frame缓存的维护和计算都不是一般的复杂，而AsyncDisplayKit却能在保持简介布局的同时，做到一帧不掉，这是多么的让人感动！ 3）更优雅的架构设计前两点好处是用AsyncDisplayKit最直接最容易被感受到的，其实，当深入使用时，你会发现，AsyncDisplayKit还会给程序架构设计带来一些改变，会使原本复杂的架构变得更简单，更优雅，更灵活，更容易维护，更容易扩展，也会使整个代码更容易理解，而这个影响是深远的，毕竟代码是写给别人看的。 但AsyncDisplayKit有一个极其著名的问题，闪烁。 当我们开始试水使用AsyncDisplayKit时，只要简单reload一下TableNode，那闪烁，眼睛都瞎了。后来查了官方的issue，才发现很多人都提了这个问题，但官方也没给出什么优雅的解决方案。要知道，闪烁是非常影响用户体验的。如果非要在不闪烁和带闪烁的AsyncDisplayKit中选择，我会毫不犹豫的选择不闪烁，而放弃使用AsyncDisplayKit。但现在已经不存在这个选择了，因为经过AsyncDisplayKit的多次迭代努力加上一些小技巧，AsyncDisplayKit的异步闪烁已经被优雅的解决了。 但AsyncDisplayKit不宜广泛使用，那些高度固定、UI简单用UIKit更好一些，毕竟AsyncDisplayKit并不像UIKit，人人都会，如果内容和高度复杂又很动态，强烈推荐AsyncDisplayKit，它会简化太多东西。 疑难点一年的AsyncDisplayKit使用经验，踩过了不少坑，遇到了不少值得注意的问题，一并列在这里，以供参考。 ASNetworkImageNode的缓存ASNetworkImageNode是对UIImageView需要从网络加载图片这一使用场景的封装，省去了YYWebImage或者SDWebImage等第三方库的引入，只需要设置URL即可实现网络图片的自动加载。 import AsyncDisplayKitlet avatarImageNode = ASNetworkImageNode()avatarImageNode.url = URL(string: \"http://shellhue.github.io/images/log.png\") 这非常省事便捷，但ASNetworkImageNode默认用的缓存机制和图片下载器是PinRemoteImage，为了使用我们自己的缓存机制和图片下载器，需要实现ASImageCacheProtocol图片缓存协议和 ASImageDownloaderProtocol图片下载器协议两个协议，然后初始化时，用ASNetworkImageNode的init(cache: ASImageCacheProtocol, downloader: ASImageDownloaderProtocol)初始化方法，传入对应的类，方便其间，一般会自定义一个初始化静态方法。我们公司缓存机制和图片下载器都是用的YYWebImage，桥接代码如下。 import YYWebImageimport AsyncDisplayKitextension ASNetworkImageNode { static func imageNode() -&gt; ASNetworkImageNode { let manager = YYWebImageManager.shared() return ASNetworkImageNode(cache: manager, downloader: manager) }}extension YYWebImageManager: ASImageCacheProtocol, ASImageDownloaderProtocol { public func downloadImage(with URL: URL, callbackQueue: DispatchQueue, downloadProgress: AsyncDisplayKit.ASImageDownloaderProgress?, completion: @escaping AsyncDisplayKit.ASImageDownloaderCompletion) -&gt; Any? { weak var operation: YYWebImageOperation? operation = requestImage(with: URL, options: .setImageWithFadeAnimation, progress: { (received, expected) -&gt; Void in callbackQueue.async(execute: { let progress = expected == 0 ? 0 : received / expected downloadProgress?(CGFloat(progress)) }) }, transform: nil, completion: { (image, url, from, state, error) in completion(image, error, operation) }) return operation } public func cancelImageDownload(forIdentifier downloadIdentifier: Any) { guard let operation = downloadIdentifier as? YYWebImageOperation else { return } operation.cancel() } public func cachedImage(with URL: URL, callbackQueue: DispatchQueue, completion: @escaping AsyncDisplayKit.ASImageCacherCompletion) { cache?.getImageForKey(cacheKey(for: URL), with: .all, with: { (image, cacheType) in callbackQueue.async { completion(image) } }) }} 闪烁初次使用AsyncDisplayKit，当享受其一帧不掉如丝般柔滑的手感时，ASTableNode和ASCollectionNode刷新时的闪烁一定让你几度崩溃，到AsyncDisplayKit的github上搜索闪烁相关issue，会出来100多个问题。闪烁是AsyncDisplayKit与生俱来的问题，闻名遐迩，而闪烁的体验非常糟糕。幸运的是，几经探索，AsyncDisplayKit的闪烁问题已经完美解决，这个完美指的是一帧不掉的同时没有任何闪烁，同时也没增加代码的复杂度。 闪烁可以分为四类， 1）ASNetworkImageNode reload时的闪烁当ASCellNode中包含ASNetworkImageNode，则这个cell reload时，ASNetworkImageNode会异步从本地缓存或者网络请求图片，请求到图片后再设置ASNetworkImageNode展示图片，但在异步过程中，ASNetworkImageNode会先展示PlaceholderImage，从PlaceholderImage—-&gt;fetched image的展示替换导致闪烁发生，即使整个cell的数据没有任何变化，只是简单的reload，ASNetworkImageNode的图片加载逻辑依然不变，因此仍然会闪烁，这显著区别于UIImageView，因为YYWebImage或者SDWebImage对UIImageView的image设置逻辑是，先同步检查有无内存缓存，有的话直接显示，没有的话再先显示PlaceholderImage，等待加载完成后再显示加载的图片，也即逻辑是memory cached image—-&gt;PlaceholderImage—-&gt;fetched image的逻辑，刷新当前cell时，如果数据没有变化memory cached image一般都会有，因此不会闪烁。 AsyncDisplayKit官方给的修复思路是： import AsyncDisplayKitlet node = ASNetworkImageNode()node.placeholderColor = UIColor.rednode.placeholderFadeDuration = 3 这样修改后，确实没有闪烁了，但这只是将PlaceholderImage—-&gt;fetched image图片替换导致的闪烁拉长到3秒而已，自欺欺人，并没有修复。 既然闪烁是reload时，没有事先同步检查有无缓存导致的，继承一个ASNetworkImageNode的子类，复写url设置逻辑： import AsyncDisplayKitclass NetworkImageNode: ASNetworkImageNode { override var url: URL? { didSet { if let u = url, let image = UIImage.cachedImage(with: u) else { self.image = image placeholderEnabled = false } } }} 按道理不会闪烁了，但事实上仍然会，只要是个ASNetworkImageNode，无论怎么设置，都会闪，这与官方的API说明严重不符，很无语。迫不得已之下，当有缓存时，直接用ASImageNode替换ASNetworkImageNode。 import AsyncDisplayKitclass NetworkImageNode: ASDisplayNode { private var networkImageNode = ASNetworkImageNode.imageNode() private var imageNode = ASImageNode() var placeholderColor: UIColor? { didSet { networkImageNode.placeholderColor = placeholderColor } } var image: UIImage? { didSet { networkImageNode.image = image } } override var placeholderFadeDuration: TimeInterval { didSet { networkImageNode.placeholderFadeDuration = placeholderFadeDuration } } var url: URL? { didSet { guard let u = url, let image = UIImage.cachedImage(with: u) else { networkImageNode.url = url return } imageNode.image = image } } override init() { super.init() addSubnode(networkImageNode) addSubnode(imageNode) } override func layoutSpecThatFits(_ constrainedSize: ASSizeRange) -&gt; ASLayoutSpec { return ASInsetLayoutSpec(insets: .zero, child: networkImageNode.url == nil ? imageNode : networkImageNode) } func addTarget(_ target: Any?, action: Selector, forControlEvents controlEvents: ASControlNodeEvent) { networkImageNode.addTarget(target, action: action, forControlEvents: controlEvents) imageNode.addTarget(target, action: action, forControlEvents: controlEvents) }} 使用时将NetworkImageNode当成ASNetworkImageNode使用即可。 2）reload 单个cell时的闪烁当reload ASTableNode或者ASCollectionNode的某个indexPath的cell时，也会闪烁。原因和ASNetworkImageNode很像，都是异步惹的祸。当异步计算cell的布局时，cell使用placeholder占位（通常是白图），布局完成时，才用渲染好的内容填充cell，placeholder到渲染好的内容切换引起闪烁。UITableViewCell因为都是同步，不存在占位图的情况，因此也就不会闪。 先看官方的修改方案， func tableNode(_ tableNode: ASTableNode, nodeForRowAt indexPath: IndexPath) -&gt; ASCellNode { let cell = ASCellNode() ... // 其他代码 cell.neverShowPlaceholders = true return cell} 这个方案非常有效，因为设置cell.neverShowPlaceholders = true，会让cell从异步状态衰退回同步状态，若reload某个indexPath的cell，在渲染完成之前，主线程是卡死的，这与UITableView的机制一样，但速度会比UITableView快很多，因为UITableView的布局计算、资源解压、视图合成等都是在主线程进行，而ASTableNode则是多个线程并发进行，何况布局等还有缓存。所以，一般也没有问题，贝聊的聊天界面只是简单这样设置后，就不闪了，而且一帧不掉。但当页面布局较为复杂时，滑动时的卡顿掉帧就变的肉眼可见。 这时，可以设置ASTableNode的leadingScreensForBatching减缓卡顿 override func viewDidLoad() { super.viewDidLoad() ... // 其他代码 tableNode.leadingScreensForBatching = 4} 一般设置tableNode.leadingScreensForBatching = 4即提前计算四个屏幕的内容时，掉帧就很不明显了，典型的空间换时间。但仍不完美，仍然会掉帧，而我们期望的是一帧不掉，如丝般顺滑。这不难，基于上面不闪的方案，刷点小聪明就能解决。 class ViewController: ASViewController { ... // 其他代码 private var indexPathesToBeReloaded: [IndexPath] = [] func tableNode(_ tableNode: ASTableNode, nodeForRowAt indexPath: IndexPath) -&gt; ASCellNode { let cell = ASCellNode() ... // 其他代码 cell.neverShowPlaceholders = false if indexPathesToBeReloaded.contains(indexPath) { let oldCellNode = tableNode.nodeForRow(at: indexPath) cell.neverShowPlaceholders = true oldCellNode?.neverShowPlaceholders = true DispatchQueue.main.asyncAfter(deadline: .now() + 0.5, execute: { cell.neverShowPlaceholders = false if let indexP = self.indexPathesToBeReloaded.index(of: indexPath) { self.indexPathesToBeReloaded.remove(at: indexP) } }) } return cell } func reloadActionHappensHere() { ... // 其他代码 let indexPath = ... // 需要roload的indexPath indexPathesToBeReloaded.append(indexPath) tableNode.reloadRows(at: [indexPath], with: .none) }} 关键代码是， if indexPathesToBeReloaded.contains(indexPath) { let oldCellNode = tableNode.nodeForRow(at: indexPath) cell.neverShowPlaceholders = true oldCellNode?.neverShowPlaceholders = true DispatchQueue.main.asyncAfter(deadline: .now() + 0.5, execute: { cell.neverShowPlaceholders = false if let indexP = self.indexPathesToBeReloaded.index(of: indexPath) { self.indexPathesToBeReloaded.remove(at: indexP) } })} 即，检查当前的indexPath是否被标记，如果是，则先设置cell.neverShowPlaceholders = true，等待reload完成（一帧是1/60秒，这里等待0.5秒，足够渲染了），将cell.neverShowPlaceholders = false。这样reload时既不会闪烁，也不会影响滑动时的异步绘制，因此一帧不掉。 这完全是耍小聪明的做法，但确实非常有效。 3）reloadData时的闪烁在下拉刷新后，列表经常需要重新刷新，即调用ASTableNode或者ASCollectionNode的reloadData方法，但会闪，而且很明显。有了单个cell reload时闪烁的解决方案后，此类闪烁解决起来，就很简单了。 func reloadDataActionHappensHere() { ... // 其他代码 let count = tableNode.dataSource?.tableNode?(tableNode, numberOfRowsInSection: 0) ?? 0 if count &gt; 2 { // 将肉眼可见的cell添加进indexPathesToBeReloaded中 indexPathesToBeReloaded.append(IndexPath(row: 0, section: 0)) indexPathesToBeReloaded.append(IndexPath(row: 1, section: 0)) indexPathesToBeReloaded.append(IndexPath(row: 2, section: 0)) } tableNode.reloadData() ... // 其他代码} 将肉眼可见的cell添加进indexPathesToBeReloaded中即可。 4）insertItems时更改ASCollectionNode的contentOffset引起的闪烁我们公司的聊天界面是用AsyncDisplayKit写的，当下拉加载更多新消息时，为保持加载后当前消息的位置不变，需要在collectionNode.insertItems(at: indexPaths)完成后，复原collectionNode.view.contentOffset，代码如下： func insertMessagesToTop(indexPathes: [IndexPath]) { let originalContentSizeHeight = collectionNode.view.contentSize.height let originalContentOffsetY = collectionNode.view.contentOffset.y let heightFromOriginToContentBottom = originalContentSizeHeight - originalContentOffsetY let heightFromOriginToContentTop = originalContentOffsetY collectionNode.performBatch(animated: false, updates: { self.collectionNode.insertItems(at: indexPaths) }) { (finished) in let contentSizeHeight = self.collectionNode.view.contentSize.height self.collectionNode.view.contentOffset = CGPointMake(0, isLoadingMore ? (contentSizeHeight - heightFromOriginToContentBottom) : heightFromOriginToContentTop) }} 遗憾的是，会闪烁。起初以为是AsyncDisplayKit异步绘制导致的闪烁，一度还想放弃AsyncDisplayKit，用UITableView重写一遍，幸运的是，当时项目工期太紧，没有时间重写，也没时间仔细排查，直接带问题上线了。 最近闲暇，经仔细排查，方知不是AsyncDisplayKit的锅，但也比较难修，有一定的参考价值，因此一并列在这里。 闪烁的原因是，collectionNode insertItems成功后会先绘制contentOffset为CGPoint(x: 0, y: 0)时的一帧画面，无动画时这一帧画面立即显示，然后调用成功回调，回调中复原了collectionNode.view.contentOffset，下一帧就显示复原了位置的画面，前后有变化因此闪烁。这是做消息类APP一并会遇到的bug，google一下，主要有两种解决方案， 第一种，通过仿射变换倒置ASCollectionNode，这样下拉加载更多，就变成正常列表的上拉加载更多，也就无需移动contentOffset。ASCollectionNode还特意设置了个属性inverted，方便大家开发。然而这种方案换汤不换药，当收到新消息，同时正在查看历史消息，依然需要插入新消息并复原contentOffset，闪烁依然在其他情形下发生。 第二种，集成一个UICollectionViewFlowLayout，重写prepare()方法，做相应处理即可。这个方案完美，简介优雅。子类化的CollectionFlowLayout如下： class CollectionFlowLayout: UICollectionViewFlowLayout { var isInsertingToTop = false override func prepare() { super.prepare() guard let collectionView = collectionView else { return } if !isInsertingToTop { return } let oldSize = collectionView.contentSize let newSize = collectionViewContentSize let contentOffsetY = collectionView.contentOffset.y + newSize.height - oldSize.height collectionView.setContentOffset(CGPoint(x: collectionView.contentOffset.x, y: contentOffsetY), animated: false) }} 当需要insertItems并且保持位置时，将CollectionFlowLayout的isInsertingToTop设置为true即可，完成后再设置为false。如下， class MessagesViewController: ASViewController { ... // 其他代码 var collectionNode: ASCollectionNode! var flowLayout: CollectionFlowLayout! override func viewDidLoad() { super.viewDidLoad() flowLayout = CollectionFlowLayout() collectionNode = ASCollectionNode(collectionViewLayout: flowLayout) ... // 其他代码 } ... // 其他代码 func insertMessagesToTop(indexPathes: [IndexPath]) { flowLayout.isInsertingToTop = true collectionNode.performBatch(animated: false, updates: { self.collectionNode.insertItems(at: indexPaths) }) { (finished) in self.flowLayout.isInsertingToTop = false } } ... // 其他代码} 布局AsyncDisplayKit采用的是flexbox的布局思想，非常高效直观简洁，但毕竟迥异于AutoLayout和frame layout的布局风格，咋一上手，很不习惯，有些小技巧还是需要慢慢积累，有些概念也需要逐渐熟悉深入，下面列举几个笔者觉得比较重要的概念 1）设置任意间距AutoLayout实现任意间距，比较容易直观，因为AutoLayout的约束，本来就是我的边离你的边有多远的概念，而AsyncDisplayKit并没有，AsyncDisplayKit里面的概念是，我自己的前面有多少空白距离，我自己的后面有多少空白距离，更强调自己。假如有三个元素，怎么约束它们之间的间距？ AutoLayout是这样的： import Masonryclass SomeView: UIView { override init() { super.init() let viewA = UIView() let viewB = UIView() let viewC = UIView() addSubview(viewA) addSubview(viewB) addSubview(viewC) viewB.snp.makeConstraints { (make) in make.left.equalTo(viewA.snp.right).offset(15) } viewC.snp.makeConstraints { (make) in make.left.equalTo(viewB.snp.right).offset(5) } }} 而AsyncDisplayKit是这样的： import AsyncDisplayKitclass SomeNode: ASDisplayNode { let nodeA = ASDisplayNode() let nodeB = ASDisplayNode() let nodeC = ASDisplayNode() override init() { super.init() addSubnode(nodeA) addSubnode(nodeB) addSubnode(nodeC) } override func layoutSpecThatFits(_ constrainedSize: ASSizeRange) -&gt; ASLayoutSpec { nodeB.style.spaceBefore = 15 nodeC.stlye.spaceBefore = 5 return ASStackLayoutSpec(direction: .horizontal, spacing: 0, justifyContent: .start, alignItems: .start, children: [nodeA, nodeB, nodeC]) }} 如果是拿ASStackLayoutSpec布局，元素之间的任意间距一般是通过元素自己的spaceBefore或者spaceBefore style实现，这是自我包裹性，更容易理解，如果不是拿ASStackLayoutSpec布局，可以将某个元素包裹成ASInsetsLayoutSpec，再设置UIEdgesInsets，保持自己的四周任意边距。 能任意设置间距是自由布局的基础。 2）flexGrow和flexShrinkflexGrow和flexShrink是相当重要的概念，flexGrow是指当有多余空间时，拉伸谁以及相应的拉伸比例（当有多个元素设置了flexGrow时），flexShrink相反，是指当空间不够时，压缩谁及相应的压缩比例（当有多个元素设置了flexShrink时）。灵活使用flexGrow和spacer(占位ASLayoutSpec)可以实现很多效果，比如等间距， 实现代码如下， import AsyncDisplayKitclass ContainerNode: ASDisplayNode { let nodeA = ASDisplayNode() let nodeB = ASDisplayNode() override init() { super.init() addSubnode(nodeA) addSubnode(nodeB) } override func layoutSpecThatFits(_ constrainedSize: ASSizeRange) -&gt; ASLayoutSpec { let spacer1 = ASLayoutSpec() let spacer2 = ASLayoutSpec() let spacer3 = ASLayoutSpec() spacer1.stlye.flexGrow = 1 spacer2.stlye.flexGrow = 1 spacer3.stlye.flexGrow = 1 return ASStackLayoutSpec(direction: .horizontal, spacing: 0, justifyContent: .start, alignItems: .start, children: [spacer1, nodeA,spacer2, nodeB, spacer3]) }} 如果spacer的flexGrow不同就可以实现指定比例的布局，再结合width样式，轻松实现以下布局 布局代码如下， override func layoutSpecThatFits(_ constrainedSize: ASSizeRange) -&gt; ASLayoutSpec { let spacer1 = ASLayoutSpec() let spacer2 = ASLayoutSpec() let spacer3 = ASLayoutSpec() spacer1.stlye.flexGrow = 2 spacer2.stlye.width = ASDimensionMake(100) spacer3.stlye.flexGrow = 1 return ASStackLayoutSpec(direction: .horizontal, spacing: 0, justifyContent: .start, alignItems: .start, children: [spacer1, nodeA,spacer2, nodeB, spacer3])} 相同的布局如果用Autolayout，麻烦去了。 3）constrainedSize的理解constrainedSize是指某个node的大小取值范围，有minSize和maxSize两个属性。比如下图的布局： import AsyncDisplayKitclass ContainerNode: ASDisplayNode { let nodeA = ASDisplayNode() let nodeB = ASDisplayNode() override init() { super.init() addSubnode(nodeA) addSubnode(nodeB) nodeA.style.preferredSize = CGSize(width: 100, height: 100) } override func layoutSpecThatFits(_ constrainedSize: ASSizeRange) -&gt; ASLayoutSpec { nodeB.style.flexShrink = 1 nodeB.style.flexGrow = 1 let stack = ASStackLayoutSpec(direction: .horizontal, spacing: e, justifyContent: .start, alignItems: .start, children: [nodeA, nodeB]) return ASInsetLayoutSpec(insets: UIEdgeInsetsMake(a, b, c, d), child: stack) }} 其中方法override func layoutSpecThatFits(_ constrainedSize: ASSizeRange) -&gt; ASLayoutSpec中的constrainedSize所指是ContainerNode自身大小的取值范围。给定constrainedSize，AsyncDisplayKit会根据ContainerNode在layoutSpecThatFits(_:)中施加在nodeA、nodeB的布局规则和nodeA、nodeB自身属性计算nodeA、nodeB的constrainedSize。 假如constrainedSize的minSize是CGSize(width: 0, height: 0)，maxSize为CGSize(width: 375, height: Inf+)(Inf+为正无限大)，则： 1）根据布局规则和nodeA自身样式属性maxWidth、minWidth、width、height、preferredSize，可计算出nodeA的constrainedSize的minSize和maxSize均为其preferredSize即CGSize(width: 100, height: 100)，因为布局规则为水平向的ASStackLayout，当空间富余或者空间不足时，nodeA即不压缩又不拉伸，所以会取其指定的preferredSize。 2）根据布局规则和nodeB自身样式属性maxWidth、minWidth、width、height、preferredSize，可以计算出其constrainedSize的minSize是CGSize(width: 0, height: 0)，maxSize为CGSize(width: 375 - 100 - b - e - d, height: Inf+)，因为nodeB的flexShrink和flexGrow均为1，也即当空间富余或者空间不足时，nodeB添满富余空间或压缩至空间够为止。 如果不指定nodeB的flexShrink和flexGrow，那么当空间富余或者空间不足时，AsyncDisplayKit就不知道压缩和拉伸哪一个布局元素，则nodeB的constrainedSize的maxSize就变为CGSize(width: Inf+, height: Inf+)，即完全无大小限制，可想而知，nodeB的子node的布局将完全不对。这也说明另外一个问题，node的constrainedSize并不是一定大于其子node的constrainedSize。 理解constrainedSize的计算，才能熟练利用node的样式maxWidth、minWidth、width、height、preferredSize、flexShrink和flexGrow进行布局。如果发现布局结果不对，而对应node的布局代码确是正确无误，一般极有可能是因为此node的父布局元素不正确。 动画因为AsyncDisplayKit的布局方式有两种，frame布局和flexbox式的布局，相应的动画方式也有两种 1）frame布局如果采用的是frame布局，动画跟普通的UIView相同 class ViewController: ASViewController { let nodeA = ASDisplayNode() override func viewDidLoad() { super.viewDidLoad() nodeA.frame = CGRect(x: 0, y: 0, width: 100, height: 100) ... // 其他代码 } ... // 其他代码 func animateNodeA() { UIView.animate(withDuration: 0.5) { let newFrame = ... // 新的frame nodeA.frame = newFrame } }} 不要觉得用了AsyncDisplayKit就告别了frame布局，ViewController中主要元素个数很少，布局简单，因此，一般也还是采用frame layout，如果只是做一些简单的动画，直接采用UIView的动画API即可 2）flexbox式的布局这种布局方式，是在某个子node中常用的，如果node内部布局发生了变化，又需要做动画时，就需要复写AsyncDisplayKit的动画API，并基于提供的动画上下文类context，做动画： class SomeNode: ASDisplayNode { let nodeA = ASDisplayNode() override func animateLayoutTransition(_ context: ASContextTransitioning) { // 利用context可以获取animate前后布局信息 UIView.animate(withDuration: 0.5) { // 不使用系统默认的fade动画，采用自定义动画 let newFrame = ... // 新的frame nodeA.frame = newFrame } }} 系统默认的动画是渐隐渐显，可以获取animate前后布局信息，比如某个子node两种布局中的frame，然后再自定义动画类型。如果想触发动画，主动调用SomeNode的触发方法transitionLayout(withAnimation:shouldMeasureAsync:measurementCompletion:)即可。 内存泄漏为了方便将一个UIView或者CALayer转化为一个ASDisplayNode，系统提供了用block初始化ASDisplayNode的简便方法： public convenience init(viewBlock: @escaping AsyncDisplayKit.ASDisplayNodeViewBlock)public convenience init(viewBlock: @escaping AsyncDisplayKit.ASDisplayNodeViewBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)public convenience init(layerBlock: @escaping AsyncDisplayKit.ASDisplayNodeLayerBlock)public convenience init(layerBlock: @escaping AsyncDisplayKit.ASDisplayNodeLayerBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil) 需要注意的是所传入的block会被要创建的node持有。如果block中反过来持有了这个node的持有者，则会产生循环引用，导致内存泄漏：class SomeNode { var nodeA: ASDisplayNode! let color = UIColor.red override init() { super.init() nodeA = ASDisplayNode { let view = UIView() view.backgroundColor = self.color // 内存泄漏 return view } }} 子线程崩溃AsyncDisplayKit的性能优势来源于异步绘制，异步的意思是有时候node会在子线程创建，如果继承了一个ASDisplayNode，一不小心在初始化时调用了UIKit的相关方法，则会出现子线程崩溃。比如以下node，class SomeNode { let iconImageNode: ASDisplayNode let color = UIColor.red override init() { iconImageNode = ASImageNode() iconImageNode.image = UIImage(named: \"iconName\") // 需注意SomeNode有时会在子线程初始化，而UIImage(named:)并不是线程安全 super.init() }} 但在node初始化时调用UIImage(named:)创建图片是不可避免的，用methodSwizzle将UIImage(named:)置换成安全的即可。 其实在子线程初始化node并不多见，一般都在主线程。 总结一年的实践下来，闪烁是AsyncDisplayKit遇到的最大的问题，修复起来也颇为费神。其他bug，有时虽然很让人头疼，但由于AsyncDisplayKit是对UIKit的再封装，实在不行，仍然可以越过AsyncDisplayKit用UIKit的方法修复。 学习曲线也不算很陡峭。 考虑到AsyncDisplayKit的种种好处，非常推荐AsyncDisplayKit，当然还是仅限于用在比较复杂和动态的页面中。","link":"/2017/07/21/asyndisplaykit/"},{"title":"生命的惯性","text":"生命好似被上帝精心编排的话剧，年少时学习，长大了工作，然后结婚生子，抚养小孩，照看父母，最后垂垂老去。一幕接着一幕，一幕赶着一幕。貌似自由意志，其实我们只有润色生活这么一点点权限。 而在某一幕中，比如工作，我们也只是尽己所能完成每一日的事情。当然随着日复一日，年复一年，薪水逐年递增，职位越干越大，工作内容也渐进宏观。从小白程序员，到编程资深程序员，到项目负责人，到CTO。没有什么会一成不变，但也没有什么会突如其来。 循序渐进，是我们的一生，也是我们的每一天，每一秒，循序渐进就是我们生命的惯性。 这没啥不好，途中会有焦虑，会有进步，会有责罚，会有掌声，会有层出不穷的新事物。但总觉得有点烦闷，因为一切都是可期的。 我们渴望着惊喜，因为惊喜让生命充盈、丰厚。 或在某个小巷，遇到一个丁香一样的姑娘，或在某个不经意的抬头，看见散落满天的星，或在某次与人会谈时，获得生命的顿悟，或在举步维艰之际，遇到一生的贵人。 生命难逃惯性，我们总期望着惊喜。惊喜也总会不期而至，但并不是无缘无故。今日生命的惊喜大多是我们昨日努力种下的种。所以当此刻想起什么非常想做最终却不曾开始的事，努力开始吧，不因资源匮乏，不因能力欠缺，不因自卑，不因懒惰，不因忙碌。殊不知。我们内心真实的渴望，才是生命的惊喜汩汩不穷的源泉。 有时偷懒一件事，错过一生。 有时多做一件事，繁华一世。 细思之，人生其实是一条幽闭狭窄只有一个出口的通道，由着生活的惯性总会到达不出意外的终点，只有勇敢坚定的尝试新事物，才能从坚硬的道壁上凿出细微的裂痕，看到另外一个方向的光，甚至改变整个通道的方向。 所以我才会坚持周更博客，虽然我不知道这会带我去到哪里，但我知道，不写生活一如往常，坚持了它总会带我去想去的地方。 “Life is like a box of chocolates. You never know what you’re gonna get.” 阿甘说生活就像一盒巧克力，你永远不知道下一块是什么味道。 但生命的惯性，是一个编写良好的黑白滤镜，抹去了生活的五彩缤纷，唯有珍惜每一个心动的瞬间，努力埋下惊奇惊喜的种子，或许你的一生才会凑够那一盒巧克力所有的味道。","link":"/2017/04/01/alwaystrying/"},{"title":"闭包捕捉(closure capture)浅析","text":"根据Swift官方文档，闭包（closure）会自动捕捉其所在上下文中的外部变量，即使是定义这些变量的上下文已经消失。寥寥数字，其实已经将闭包捕捉说的足够清晰明了，只是其中隐含的诸如捕捉的具体含义、捕捉的时机、被捕捉变量的特性和捕捉列表的意义等细节，如不详加研究，使用闭包还是会错误百出，难以挥洒自如。 本文中所有代码均在playground中运行，若欲在实际项目中测试，需做部分修改，但基本逻辑和结论不变 ——————— 本文部分结论和例子根据部分读者意见做了修正更新，感谢他们 ——————— 捕捉的含义闭包捕捉等同于copy闭包捕捉某个变量就意味着copy一份这个变量，值类型的变量直接复制值，引用类型的变量复制引用。复制后的变量名同被捕捉的变量，复制后的变量仍为变量，常量仍为常量。看例子 值类型捕捉import UIKitstruct Pet { var name: String init(name: String) { self.name = name } func printNameClosure() -&gt; () -&gt; Void { return { print(self.name) } }}var pet: Pet = Pet(name: \"旺旺\") let cl = pet.printNameClosure() //1pet.name = \"强强\"cl() //2 结构体Pet的实例方法printNameClosure()返回一个捕捉了self实例本身的闭包，Pet为值类型，因此//1行代码执行完成后，闭包cl复制了一份存储在变量pet中名为旺旺的Pet实例，那么当存储在变量pet的Pet实例改名为强强时，闭包cl所捕捉的Pet实例不变，名字仍为旺旺，因此输出结果为：旺旺 我想您应该会有疑问，为什么上述示例代码不写的更简洁些：...//此行以前代码不变var pet: Pet = Pet(name: \"旺旺\") let cl = { print(pet.name)}pet.name = \"强强\"cl()事实上，上述示例代码中的闭包cl并未捕捉任何变量，关于闭包捕捉发生的时机下文中会有详细介绍。 引用类型捕捉import UIKitclass Pet { var name: String init(name: String) { self.name = name } func printNameClosure() -&gt; () -&gt; Void { return { print(self.name) } }}var pet: Pet = Pet(name: \"旺旺\") let cl = pet.printNameClosure() //1pet.name = \"强强\"cl() //2 这次Pet类型为类，是引用类型，因此//1行代码执行完成后，闭包cl复制了一份变量pet所指向的名为旺旺的Pet实例引用，此时变量pet与闭包cl捕捉的pet指向同一Pet实例，那么当变量pet所指向的Pet实例改名为强强时，闭包cl所捕捉的Pet实例名字也改为强强，因此输出结果为：强强 引用类型变量被捕捉后的特性引用类型变量被捕捉意味着变量所指向的类的引用被复制，也即引用计数会加一，因此为强持有。 因为引用类型变量捕捉的强持有特性，有时候会产生引用环，导致内存泄漏，解决办法官网文档已有，这里不再赘述。import UIKitclass Pet { var name: String init(name: String) { self.name = name } func printNameClosure() -&gt; () -&gt; Void { return { print(self.name) } }}var pet: Pet? = Pet(name: \"旺旺\") let cl = pet?.printNameClosure() pet = nil //1cl!()闭包cl捕捉了变量pet所指向的Pet实例，而引用类型闭包捕捉为强持有，因此变量pet所指向的Pet实例的引用计数为2，那么当在//1行设置变量pet为nil时，pet所指向的Pet实例的引用计数减为1，并不销毁，因此输出结果为：旺旺 闭包捕捉发生的时机当闭包所使用外部变量的作用域未结束时，闭包只是简单使用外部变量，并不捕捉。看例子： import UIKitclass Pet { var name: String init(name: String) { self.name = name } deinit { print(\"\\(name)升天了！\") }}//someFunc函数内部是一个局部上下文func someFunc() { //局部上下文1 var pet: Pet? = Pet(name: \"旺旺\") func printNameBlock() -&gt; () -&gt; Void { //局部上下文2 return { print(pet?.name) } } let cl = printNameBlock()//1 cl() //2 pet = nil //3 cl()}someFunc() //4 函数someFunc()的内部函数printNameBlock()返回一个闭包，被返回的闭包定义在局部上下文2中，并使用了局部上下文1中的变量pet。虽然//1行变量cl存储了内部函数printNameBlock()返回的闭包，但这个闭包从初始化到销毁整个生命周期中，并未脱离其使用的外部变量pet的作用域即局部上下文1，那么闭包cl并不捕捉外部变量pet。因此当//3行设置pet为nil时，变量pet所指向的Pet实例变量被销毁，最终的输出结果为：Optional(\"旺旺\")旺旺升天了！nil 如果闭包所使用的外部变量的作用域结束，而闭包或因被返回，或作为参数传递给其他函数而仍然存在时，闭包自动捕捉其使用的外部变量。看闭包被返回的例子 闭包被返回import UIKitclass Pet { var name: String init(name: String) { self.name = name } deinit { print(\"\\(name)升天了！\") }}//someFunc函数内部是一个局部上下文func someFunc() { //局部上下文1 var pet: Pet? = Pet(name: \"旺旺\") func printNameBlock() -&gt; () -&gt; Void { //局部上下文2 let pet2 = pet return { print(pet2?.name) } } let cl = printNameBlock()//1 cl() //2 pet = nil //3 cl()}someFunc() //4 上述示例与1）中示例相比，仅在内部函数printNameBlock()的局部上下文2中新增加了一个变量pet2，指向局部上下文1中变量pet所指向的名为旺旺的Pet实例，内部函数printNameBlock()返回的闭包使用了变量pet2，当这个闭包被返回时，其使用的外部变量pet2的作用域即局部上下文2也同时结束，因此变量pet2被捕捉。那么//1行执行结束后，闭包cl捕捉了变量pet2，则变量pet所指向的名为旺旺的Pet实例的引用为2，当在//3行设置pet为nil时，其指向的名为旺旺的Pet实例的引用只是降为1而已，并不销毁，因此最后的输出结果为：Optional(\"旺旺\")Optional(\"旺旺\")旺旺升天了之所以仍然输出旺旺升天了，是因为//4行someFunc()调用结束后，闭包cl被销毁，其捕捉的变量随即也都被销毁。 闭包被传递在异步请求时，任务常常被包装为闭包，作为参数提交给GCD或NSOperationQueue执行。import UIKitstruct Pet { //局部上下文1 var name: String init(name: String) { self.name = name } mutating func changeNameTo(name: String) { //局部上下文2 //异步 let dispatchQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) dispatch_async(dispatchQueue) { //局部上下文3 self.name = name sleep(1) //1 } }}var pet = Pet(name: \"旺旺\") pet.changeNameTo(\"强强\")sleep(3) //2print(pet.name) //3上例中的Pet是一个struct，是个值类型，其实例方法changNameTo(_:)使用异步修改了自己的名字，异步的任务闭包使用了局部上下文1中的self即实例本身，但是否捕捉self，还取决于异步任务执行结束时，局部上下文1是否结束。在上述示例中，//1行使得闭包任务睡眠1s，因此保证了闭包任务执行结束时，局部上下文2已经结束，也即局部上下文1已经结束，因此闭包任务捕捉了self实例本身，//2行睡眠了3秒，保证了//3行输出Pet实例名字时，异步任务已经执行完成，但由于传入异步任务的闭包捕捉了self，因此并不能达到修改Pet名字的目的，输出结果为：旺旺稍微修改下，让局部上下文2睡眠1s。import UIKitstruct Pet { //局部上下文1 var name: String init(name: String) { self.name = name } mutating func changeNameTo(name: String) { //局部上下文2 //异步 let dispatchQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) dispatch_async(dispatchQueue) { //局部上下文3 self.name = name } sleep(1) //1 }}var pet = Pet(name: \"旺旺\") pet.changeNameTo(\"强强\")sleep(3) //2print(pet.name) //3由于//1行代码让局部上下文2睡眠1s，因此导致异步任务执行结束时，self所在的局部上下文1仍在，那么异步任务闭包并不捕捉self，因此可以达到修改Pet名字的目的，那么输出结果为：强强 如果将上述两个例子都改为同步，那么，根据同步的性质，同步任务闭包一定不捕捉self:import UIKitstruct Pet { //局部上下文1 var name: String init(name: String) { self.name = name } mutating func changeNameTo(name: String) { //局部上下文2 //同步 let dispatchQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) dispatch_sync(dispatchQueue) { //局部上下文3 self.name = name sleep(1) //1 } }}var pet = Pet(name: \"旺旺\") pet.changeNameTo(\"强强\")sleep(3) //2print(pet.name) //3由于是同步任务，意味着局部上下文2一直会等到局部上下文3返回才返回，也即在局部上下文3执行时，局部上下文2一直未结束，因此同步任务闭包并不捕捉self，则结果为：强强需要注意的是，Swift中对值类型的使用达到了空前的程度，因此我们常用struct定义model，如果在model我们还异步请求数据，那么根据闭包的捕捉特性，可能请求了两年也不会有结果。如果改为引用类型，则没有这种隐患，因此如果模型需使用异步请求数据，定义时选择引用类型更合适。 闭包中如果定义了捕捉列表，闭包在定义时立即capture捕捉列表中所有变量，并将捕捉的变量一律改为常量，供自己实用。闭包捕捉一般发生在所使用的外部常量所在上下文结束时，但如果闭包定义了捕捉列表，闭包在初始化时立即捕捉捕捉列表中的变量，并将捕捉的变量一律改为常量，这也是捕捉列表应有的意义。 对比两个示例，一个添加了捕捉列表，一个没有。var i = 18let cl = { //并未添加捕捉列表 print(i)}i = 100cl()闭包cl所使用的外部变量i的局部作用域一直未结束，因此闭包cl只是简单的使用变量i，并不捕捉，无论i如何变，cl调用时都会使用自己被调用时刻i的最新值，因此输出结果为：100如果添加捕捉列表：var i = 18let cl = { [i] in //添加了捕捉列表 print(i)}i = 100cl()闭包cl所使用的外部变量i的局部作用域虽未结束，但由于闭包cl定义了捕捉列表，因此闭包cl在其定义完成时，即捕捉了变量i，copy了一份i，由于i是值类型，copy后与变量i不再有任何关系，因此输出结果：18当然由于捕捉列表中捕捉的变量均被改为常量，在闭包内无法修改捕捉变量的值：var i = 18let cl = { [i] in //添加了捕捉列表 i = 56 //此行报错 print(i)}i = 100cl()上述示例在闭包内部修改了捕捉变量i的值，但由于捕捉列表中的变量在捕捉后均被改为常量，因此会报错。 结论经过上述分析，closure capture主要有四个特性，1）闭包capture某个变量等于copy一份这个变量，值类型的变量直接复制值，引用类型的变量直接复制引用值，与函数中参数传递类似，复制后的变量名同被捕捉的变量。 2）如果闭包所使用的外部变量的作用域未结束，闭包只是简单使用这些外部变量，并不捕捉。3）闭包捕捉发生在闭包所使用的外部变量的作用域结束，而闭包或因被返回，或作为参数传递给其他函数而仍然存在时。第2和第3点讲的都是闭包捕捉的时机，其实可以总结为一句话，闭包捕捉发生在其所使用的外部变量即将销毁的时刻，也即你再不捕捉我就没了。这也意味着，当闭包捕捉多个外部变量，而这些外部变量的作用域不同时，闭包按照各个外部变量作用域结束的先后次序进行变量捕捉，并非一次性捕捉。 4）闭包中如果定义了捕捉列表，闭包在定义时立即capture捕捉列表中所有变量，并将捕捉的变量一律改为常量，供自己实用。 闭包捕捉苹果官方文档中介绍的非常简略，上述只是所有的特性也是我多番实验得出的结论，对于理解closure capture暂时应该是够了。 鸣谢由于文章写的有点仓促，部分结论未经严谨论证就直接摆出来了，幸好部分网友大牛及时指正，真是无与伦比的感谢。他们是strider，小吻子, 来扶爷试玩个波。非常感谢他们，也欢迎各路大神继续留言讨论批评指正。","link":"/2016/04/22/closureCapture/"},{"title":"iOS并发（concurrency）概念浅析","text":"在进行iOS开发过程中，我们常会遇到网络请求、复杂计算、数据存取等比较耗时的操作，如果处理不合理，将对APP的流畅度产生较大影响。除了优化APP架构，并发（concurrency）是一个常用且较好的解决方法，但并发涉及串行、并发、并行、同步、异步、多线程、GCD、NSOperation和NSOperationQueue等诸多容易混淆的概念，为求概念清晰明了，还请茗茶静坐，听我徐徐道来。 线程和任务线程（thread） 和任务（task）是其他并发概念的基础，因此也是首要需理清的概念，以下是其要点，详细可参考Thread (computing)和Task (computing))。 任务（task）a）任务（task）是从程序中划分出来，可以独立执行的代码片段；b）任务间可以添加依赖关系，如B任务依赖A任务，taskB.addDependency(taskA)，这意味着B任务的执行以A任务完成为前提。 需要注意的是一个任务是否可以添加依赖，完全取决于任务封装类和其相关管理类的具体实现，GCD不支持任务依赖，NSOperationQueue就支持任务依赖。 下面的代码是对一个任务的简单封装，并支持任务间的依赖。//Task是一个任务的简单封装类class Task { let taskBlock: () -&gt; () var dependencies = [Task]() init(block: () -&gt; ()) { taskBlock = block } func addDependency(task: Task) { dependencies.append(task) }}//初始化两个自定义任务var taskA = Task(){ //自定义任务A，自定义需要执行的代码 ...}var taskB = Task(){ //自定义任务B，自定义需要执行的代码 ...}//添加依赖关系taskB.addDependency(taskA) 线程（thread）a）线程（thread）是代码执行的独立路径，一条线程只能同时执行一行代码（一行代码，其实就是一条处理器命令）。b）线程中代码管理是以任务（task）为单位，一条线程逐行执行一个任务中的代码（任务可以取消），完成后再逐行执行下一个任务中的代码。c）一条线程跳出一个任务的执行，即意味着这个任务的完成。因此，一条线程不能执行taskA一段时间后，还未完成就开始执行taskB，然后又返回执行taskA（这其实是单线程内的并发，与单核处理器的并发概念相同，具体实践中不存在线程内并发）。 概念释疑并行（parallelism）和并发（concurrency）并发和并行都是指多个任务可以同时执行，都属于多线程编程概念，因此二者必然十分相近，容易混淆。二者区别只有一点，即是否多任务执行于严格的同一时刻。并发不是，并行是。 单核处理器时代（一个处理器同一时刻只能执行一条命令），为了实现多任务的同时执行，系统利用时间分片（time-slicing）技术，将处理器的执行时间切分为多个小片段，一会执行threadA，一会执行threadB，一会再执行threadA，即在多个线程（任务是在线程上执行的）之间来回跳动执行。虽不是真的多线程多任务同时执行，但由于处理器的处理速度非常快，在用户看来，仍然是同时执行的。这种伪多线程就是并发。 多核处理器时代（不同处理器相互独立，可以同时执行各自的命令），多条线程完全可以严格同一时刻执行，这种真多线程就是并行。//三个线程的并发thread1 -&gt; |---A---| -&gt;|---A---| \\ / \\thread2 ------&gt; -&gt;|------B----| \\thread3 ------------------------------------&gt; |------C------|上述代码是三个线程的并发执行，可以看出thread1、thread2和thread3不可能严格同一时刻执行，但也都获得了处理器的一小段执行时间。 //三个线程的并行thread1 -&gt; |-----A-----|thread2 -&gt; |------B----|thread3 -&gt; |------C------| 上述代码是三个线程的并行执行，可以看出thread1、thread2和thread3有一段时间同时执行。 现在的终端设备无论是手机还是PC的处理器，大多都已是多核处理器，可以实现并行计算，但为了最大化的利用处理器的性能，现代处理器还是融合了time-slicing技术和多核技术，因此实际运行中，有时并发，有时并行。但相对来说，并发是个更广泛的概念，因此Apple的多线程编程叫做concurrency programming并发编程。汉语中，并发和并行的区别其实没那么清晰，可以互用，而且有时用并行更加明确，如串并行比串行、并发针对性更强。（为概念清晰期间，下文中有时会用并行，其实即是并发。） 串并行与线程串行（serial）和并行串行和并行主要区别在于一个任务的执行是否以上一个任务的完成为前提。串行中，一个任务的执行必须以上一个任务执行结束为前提，并行中，一个任务的执行与上一个任务的执行状态无关。以排队买票为例，串行像单个买票队伍，单个卖票窗口，必须一个一个来，串行像单个买票队伍，多个卖票窗口，多个人可以同时买票。//三个串行任务|-----A-----||------B--------||----C--|上文为三个串行任务，任务A完成后，才执行任务B，B结束后，才最后执行任务C。//三个并发任务|-----A-----| |------B----| |--C---|上文为三个并行任务，任务A早于任务C开始，却晚于任务C结束。 串并行与线程串并行主要关注多个任务之间的相互依赖关系，与线程无关。但实际中，任务是在线程中执行的，是否串行一定在单线程上执行，并行一定在多个线程中执行呢？并非如此。单线程既可以实现串行，也可以实现并行。//单线程串行1 thread -&gt; |----A-----||-----B-----------||-------C------|//单线程并行（理论上，实际中不可行） A-Start ---------------------------------------- A-End | B-Start ----------------------------------------|--- B-End | | C-Start -------------------- C-End | | V V V V V V 1 thread-&gt; |-A-|---B---|-C-|-A-|-C-|--A--|-B-|--C--|---A-----|--B--|需要指出的是单线程内的并行已经类似单核处理器，并不是本文提及的常规线程，现实中也不常见。 多线程既可以实现串行，也可以实现并行，实际上，多线程串行和并行都很常见。//多线程串行thread1 -&gt; |----A-----| \\ thread2 ---------------&gt;|-----B-----------| \\ thread3 -----------------------------------&gt;|-------C------|//多线程并发 thread1 -&gt; |----A-----| thread2 -----&gt; |-----B-----------| thread3 ---------&gt; |-------C----------| 同步（synchronize）、异步（asynchronous）与线程同步和异步是站在当前线程的角度，考察添加任务到新线程后，何时返回到当前线程执行下面的代码的问题，也即新添加的线程阻不阻塞当前线程。 同步override viewDidLoad() { super.viewDidLoad() let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) dispatch_sync(queue) { //block1 print(\"-----1-----\") //1 return } print(\"-----2-----\") //2} block1是添加到系统全局队列中的新任务，由于是同步的，因此block1执行返回后，才会回到当前主线程，执行//2及以后的代码。输出结果为：-----1----------2----- 异步//viewDidLoad()在主线程中执行，因此当前线程为主线程override viewDidLoad() { super.viewDidLoad() let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) dispatch_async(queue) { //block1 print(\"-----1-----\") //1 return } print(\"-----2-----\") //2} block1是添加到系统全局队列中的新任务，由于是异步的，因此block1添加全局队列后（会在另外一个线程上执行），不等到执行完成，就会返回到当前主线程，执行//2及以后的代码，所以输出结果可能为 21 12。但由于block1和主线程中的任务都是不耗时的简单任务，而创建新的线程是要消耗一定时间的（主线程一直存在，不用新创建），因此很可能的输出结果是：-----2----------1----- 同异步结合的情形如果同异步结合://viewDidLoad()在主线程中执行，因此当前线程为主线程override viewDidLoad() { super.viewDidLoad() let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) dispatch_async(queue) { //block1 print(\"-----A-----\") //1 dispatch_async(dispatch_get_main_queue()) { //block2 print(\"-----B-----\") //2 } print(\"-----C-----\") //3 return } print(\"-----D-----\") //4 while(true) { } //5 print(\"-----E-----\") //6}block1是添加到系统全局队列中的新任务，由于是异步的，因此block1添加全局队列后（会在另外一个线程上执行），不等到执行完成，就返回到当前主线程，执行//4及以后的代码，结果是block1所在的线程与主线程同时执行，因此理论上，D和A谁先输出不一定。但由于block1和主线程中的任务都是不耗时的简单任务，而创建新的线程是要消耗一定时间的（主线程一直存在，不用新创建），因此一般输出结果为DA。 block1所在线程输出完A后，将block2添加到主调度队列中，由于是异步的，因此block2添加主调度队列后（会在主线程上执行），不等到执行完成，就返回到block2所在的线程，继续执行，因此A和C一定会输出，且C一定在A之后输出。但block2却不一定能执行，因为block1在执行时，主线程也在执行（主线程是串行单线程，任务按顺序一个一个执行），如果此时主线程执行到//5对应的死循环，则block2一定不能被执行，B一定不能被输出，如果此时主线程尚未执行到//5对应的死循环，block2已经添加到主线程中，则block2会被执行，B能被输出。但由于主线程无需另外创建，block1（所对应的线程需另外创建）执行到添加block2到主调度队列时，主线程很可能已经执行到//5对应的死循环，因此block2很可能不被执行。 //6前有个死循环，因此E一定不会被输出。 因此可能的输出结果是；DAC ADC ADCB DACB ACDB ACBD ABDC ABCD但很可能的输出结果为：-----D----------A----------C----- 同异步与串并行串行和同步，并行和异步似是完全不同的概念，一个关注任务的独立关系，一个看中的是返回的时机。但事实上，串行和同步近似，并发和异步相同，他们指代的事情几乎完全相同。就同步和串行而言，需要任务执行结束后才能返回，其实就是一个任务执行完成后，才能执行其他的任务，反应的就是串行依赖关系。 而异步和并行就更相同了，不等任务执行完成，就直接返回，反应的就是并发任务之间的独立性。 当然，同异步所暗含的串行和并行是当前线程的任务与新线程的任务之间的相互关系。 GCD与NSOperationQueueGCD(grand central dispatch)和NSOperationQueue二者均是系统级的多线程封装，在使用时，我们只需创建任务队列即可，其他的如线程创立、任务分配等，均由系统自动处理。不得不说，这让多线程编程变得更高效，更简单，当然并不是没有坑。需要强调的是，GCD和NSOperationQueue的使用核心是任务（task）和任务队列（task queue），暂时可以忘了线程（thread）这烦人的概念。 关于GCD和NSOperationQueue网上已经有不少高质量的文章对其详细介绍，我推荐《iOS并行开发：从NSOperation和调度队列开始》，其对基本概念、使用方法等的介绍非常清晰详尽，我这里就不再赘述了，只写一些我认为容易忽略却影响认知深度的小知识点。当然如果你英语过硬，去直接看官方文档《ConcurrencyProgrammingGuide》是最好的。 GCDGCD是基于C的API，因此比较底层。 GCD所管理的调度队列（dispatch queue）主要有三类，串行队列（private dispatch queue）、并发队列 （global dispatch queue，又称全局调度队列）和主队列（main dispatch queue）。 我们常用的 dispatch_get_global_queue(_:_:)所获得的dispatch queue就是全局调度队列(global dispatch queue)，并发，而且全局调度队列是全局共用的，每一个优先级的全局调度队列只有一个实体。四种不同优先级的全局调度队列对应的四种优先级的线程，同一个优先级的全局调度队列可以同时拥有多条相应优先级的线程。 dispatch_get_main_queue()所获得的dispatch queue是主调度队列，主调度队列是串行队列。 NSOperationQueueNSOperationQueue是对GCD的Objective-C封装，相对于GCD具有更多先进的特性，如可以添加NSOperation依赖，取消NSOperation等。 NSOperationQueue是并发队列，且不遵循先进先出FIFO排序原则。 总结与感悟上文基本就是我对并发的认识，有几个点我想在这里再强调下，1）串并行、同异步与线程无关，单线程、多线程都可以实现串并行和同异步。2）串行和同步相同，异步和并行相同，他们只是看待同一件事物的角度不同。3）GCD和NSOperationQueue的使用核心是任务（task）和任务队列（task queue）。4）全局调度队列(global dispatch queue)是全局共用的，系统有时也会向这些调度队列添加系统任务。5) App的主调度队列是串行单线程队列。 通过本文的浅析，希望达到了理清概念的最初目的，当然这些只是并发编程的第一步，并发线程还有竟态资源、死锁等诸多大坑，要想真正掌握，我们继续努力。","link":"/2016/04/15/concurrency/"},{"title":"如何在iOS开发中更好的做假数据？","text":"当工期比较紧的时候，项目开发中会经常出现移动端等待后端接口数据的情形，不但耽误项目进度，更让人有种无奈的绝望。所以在开发中，我们常常自己做些假数据，以方便开发和UI调试。然而做假数据方法不同，效率和安全性都各不同，有时稍有不慎，还会产生很大的bug。因此本文拟结合我在贝聊的开发经验，讲一讲我们组在iOS开发中曾经用过的做假数据的方法及其优劣。 示例项目为方便下文的说明，本文主要以贝聊家长版app发现首页的热门帖子列表的实现为例。热门帖子列表的样式如下图：这是比较常见的列表，用常用的UITableView实现即可，但需要自定义一个的UITableViewCell的子类ExploreTableViewCell。项目中，ExploreTableViewCell并没有用xib实现（因为xib日后不好修改，且代码复用性差），而是通过SnapKit用纯代码布的局，具体的布局代码大致如下： import UIKitimport SnapKitclass ExploreTableViewCell: UITableViewCell { let thumbnailImageView: UIImageView let titleLabel: UILabel let avatarImageView: UIImageView let authorNameLabel: UILabel let viewCountLabel: UILabel let commentCountLabel: UILabel //...其他属性 override init(style: UITableViewCellStyle, reuseIdentifier: String?) { //创建view thumbnailImageView = UIImageView() titleLabel = UILabel() avatarImageView = UIImageView() authorNameLabel = UILabel() viewCountLabel = UILabel() commentCountLabel = UILabel() //...其他view的创建 super.init(style: style, reuseIdentifier: reuseIdentifier) //设置view titleLabel.numberOfLines = 2 titleLabel.textColor = UIColor.black titleLabel.snp.makeConstraints { (make) -&gt; Void in make.left.equalTo(thumbnailImageView.snp.right).offset(15) make.right.equalTo(contentView.snp.right) make.top.equalTo(contentView.snp.top) } //...其他view的设置 } //...其他业务代码} 源码中写死源码中写死数据是最便捷的假数据做法，项目很赶时，为最快速的看到UI效果，一般都会采取这种假数据方式。比如在上述热门帖子列表示例项目中，为查看整个ExploreTableViewCell的布局效果，在titleLabel等subview的设置位置，直接写死假数据。//...其他代码override init(style: UITableViewCellStyle, reuseIdentifier: String?) { //...其他初始化代码 //写死的假数据代码 titleLabel.text = \"这是一个标题这是一个标题这是一个标题这是一个标题这\" thumbnailImageView.image = UIImage(named:\"sampleImage\") avatarImageView.image = UIImage(named:\"sampleImage\") authorNameLabel.text = \"作者名\" viewCountLabel.text = \"1000\" commentCountLabel.text = \"1000\" //...其他初始化代码}//...其他代码源码中写死假数据虽然方便，但稍有不慎就容易直接上线上环境（因为测试在测试时一般都会有数据，假数据被遮盖了），演变成一个有可能非常严重也有可能很轻的bug（贝聊就切实出现过这样的bug，而且还是个影响广泛的大bug），为安全起见，所有写死的假数据都应该包在条件编译宏内。//...其他代码override init(style: UITableViewCellStyle, reuseIdentifier: String?) { //...其他初始化代码 //写死的假数据代码，包裹在条件编译宏内 #if DEBUG titleLabel.text = \"这是一个标题这是一个标题这是一个标题这是一个标题这\" thumbnailImageView.image = UIImage(named:\"sampleImage\") avatarImageView.image = UIImage(named:\"sampleImage\") authorNameLabel.text = \"作者名\" viewCountLabel.text = \"1000\" commentCountLabel.text = \"1000\" #endif //...其他初始化代码}//...其他代码包在条件编译宏内，就可以保证不污染正式环境的代码，从而保证安全性。 利用单元测试的网络请求stub做假数据在源码中写死假数据，有以下三个缺点， 污染源代码假数据写在源代码中，即使用宏包裹起来，只是保证了一定的安全性，但依然污染了源代码，如果上线前忘了把假数据代码移除，它一直会残留在源代码中，而且还会一直影响DEBUG环境的调试。 假数据散落四处，无法集中管理本文示例代码的假数据虽然写在一块，但在实际开发中，并不是所有的UI代码都在一个文件中。即使在一个文件内，往往各个属性的初始化和设置也不在一个方法内。代码一多，基本很难管理。 扭曲了数据的正确流通正确的数据产生方式，应该是发一个网络请求，然后把请求回来的数据转成model，最后通过model给各个UI组件填充数据。而在源代码中写死假数据，直接打乱了数据的正确流通，这会使得整个开发的逻辑是颠倒的，不但使开发更容易出bug，而且逻辑流的切换带来的开发效率和开发感受都很差。 较好的假数据方式，应该尽可能的不污染源代码，不扰乱正常的数据流通，而且能集中管理。在研究单元测试时，我无意中发现stub某个页面请求数据的网络请求即可达到这种完美的假数据效果。 首先按正常的流程开发整个功能，（在开发中，我总是倾下于先创建Model，而不是先写UI） 创建Model 创建ViewController 创建View等UI元素 在ViewController中完成网络请求的发起，并完成从网络数据到Model的转换 应用Model填充UI 整个功能开发按照有真实网络请求进行，但事实上并没有网络请求，因为后台并未搭好，没关系，先按照后台给出的接口和数据格式定义，创建一个本地JSON文件。对于本文的示例（假定只有列表数据）来说，文件名暂为hotTopics.json，内容大致如下（贝聊发现首页实际上有很多其他元素，网络请求返回的JSON也比这个复杂的多）：{ hotTopics: [ { &quot;title&quot;: &quot;这是一个标题这是一个标题这是一个标题&quot;, &quot;thumbnail&quot;: &quot;https://api.beiliao.com/explore/image/fdlafjlfp34523.jpg&quot;, &quot;author&quot;: &quot;小黄老师&quot;, &quot;authorAvatar&quot;: &quot;https://api.beiliao.com/explore/image/fdlafjlfp34523.jpg&quot;, &quot;commentCount&quot;: 1000, &quot;viewCount&quot;: 3000 }, { &quot;title&quot;: &quot;这是另外一个标题这是另外一个标题这是另外一个标题&quot;, &quot;thumbnail&quot;: &quot;https://api.beiliao.com/explore/image/fdla32131fjlfp34523.jpg&quot;, &quot;author&quot;: &quot;小李老师&quot;, &quot;authorAvatar&quot;: &quot;https://api.beiliao.com/explore/image/fdl232afjlfp34523.jpg&quot;, &quot;commentCount&quot;: 1030, &quot;viewCount&quot;: 3400 } ]}然后在ViewController中stub本ViewController中所有的网络请求，我在开发中用的是OHHTTPStubs，大致的代码如下：class ExploreViewController: UITableViewController { //...其他代码 override func viewDidLoad() { super.viewDidLoad() //...其他代码 #if DEBUG stubRequests() #endif //...其他代码 } //...其他代码 func stubRequests() { stub(isPath(\"/explore/hotTopics\")) { _ in let stubPath = OHPathForFile(\"hotTopics.json\", type(of: self)) return fixture(filePath: stubPath!, headers: [\"Content-Type\":\"application/json\"]) } }}注意所创建的JSON文件一定要加到项目目录中。添加完上述代码后，path为/explore/hotTopics的网络请求将被stub，返回的数据将是所指定JSON文件中的数据，这样就跟真实的网络请求没有任何的区别了。而且利用OHHTTPStubs还可以模拟网络请求失败、网络请求超时以及throttle等各种网络请求状态，从而更全面的调试UI和整个功能。 利用stub做假数据可以真实的做到基本不污染代码、集中管理和完全真实的数据流通流程，与在源码中写死这种方式相比，近乎完美。然而当你真正用过一段时间后，你会发现，这种方式还是有一个致命的缺点和一个不那么重要的缺点。 不适合做UI调试因为每改动一次数据，都需要重新编译，而iOS编译是很慢的，尤其是Swift。而要想做UI调试，频繁的改动数据，查看各种边界条件下的UI是必然的。 还是污染了代码虽然相较上一种方法，污染非常小，但或多或少还是有污染的，有强迫症的人是受不了的，而且有时测试说是个bug（测试包一般是BETA环境），你build一下发现数据是假数据，不是网络请求的数据，还需要找到stub网络请求的位置，然后把代码注释了，也是极其的烦人的。 如果能做到每改动一下数据，然后刷新一下就可以看到了，像网页一样，而且真的一点都不污染代码，那就是完美的解决方案。 动态注入如果只是想做到，每改动一下数据，然后刷新以下就可以看到了，像网页一样，Xcode的动态注入是可以的，现在比较流行的是 injectionforxcode和dyci-main两个库。利用单元测试的网络请求stub做假数据，然后结合动态注入，理论上应该可以做到实时刷新，但事实上injectionforxcode和dyci-main的体验都是很糟糕的，时灵时不灵，我用过两次后，基本就不想碰了，我宁愿编译慢一点，当然我从来没有用动态注入去做假数据的实时刷新，但我觉得应该是个方案。 但这个方案即使可行，也还是会污染代码，并不算特别彻底的方案。真正彻底的方案，与用stub拦截网络请求的思路相同，只是要将网络请求的拦截放到整个APP外，有两个方案可行。 本地自己搭个服务器第一种就是本地自己搭个服务器，然后把开发时需要拦截的网络请求地址改为自己搭建的服务器地址，然后返回自己自定义的JSON数据。但这种方式也有三个缺点： 有一定门槛虽然搭建服务器是很简单的事，并不是所有人都会，也是需要一定的学习成本的。 还是要修改源码中网络请求的地址这虽然已经把源码污染降到最低了，但毕竟还是有。 要想模拟不同的网络状态，还需去修改服务器的代码，不方便。综合起来这种方案性价比并不高，但确实有一定的趣味性，毕竟自己折腾东西嘛。 网络代理第二种就是利用现有的网络代理软件，直接拦截对应的网络请求，然后返回本地写好的JSON数据。我最终采用的这种方案（因为我嫌配置服务器麻烦）。将APP中所有的网络请求都代理给网络代理，然后指定特定的网络请求返回本地JSON数据。这种方案的好处不言而喻， 真正的不污染源码源码中任何代码都不用动，真正做到了干净绿色无污染。 拦截起来很方便许多网络代理软件，都自带拦截甚至改写网络请求的功能，所以启动拦截功能很方便。 方便调试网络代理一般都有改变一个网络请求状态的功能，可以轻松实现返回网络错误、网络超时和延迟网络请求等不同的网络请求状态的功能，非常方便。 我常用的网络代理就是Charles，相信大家都有耳闻。Charles有个maplocal的功能（在工具菜单下），如图: mapLocal的设置也很简单，在Location一栏填上所要拦截的网络请求的host、path或者完整的URL，然后在LocalPath一栏选择对应的本地JSON文件即可，记得勾选启动。 这样简单的设置后，所指定的网络请求都会返回本地对应的JSON文件数据。然后你将发现这种假数据之完美，简直让人窒息。 编译后，如果想改变一个数据，看看对应的UI，直接去改变本地JSON文件，然后下来刷新一下，你会发现显示的数据就是刚刚改动的数据，简直要感动哭了。 但事实上这种方式还是有一个小小的缺点，即Charles与Shadowsocks不能同时开着，因为Charles不支持父代理。搞编程开发，为方便查阅资料，翻墙软件会一只开着，但这样Charles就不能开着，想用的话，又要先退出Shadowsocks，再打开Charles，这让我很头疼。最后只能在真正写完所有的逻辑和UI后，关闭Shadowsocks，打开Charles，集中调试。 =============2017-03-04更新开始=============== 文章发出后，不少读者反馈， Charles与Shadowsocks可以共存具体怎么共存，我还有待研究，后续文章再做补充 假数据的数据应该能随机生成具体由json server、mock.js和Charles三者结合完成，有意思，值得研究，待后续文章详细补充。 =============2017-03-04更新结束=============== 总结一路试下来，其实只有第一种源码中写死和最后一种网络代理两种假数据方式最常用，虽然第一种缺点最多，但方便快捷，最后一种虽无任何缺点，但启动还是有点麻烦。 写了这么多，还是希望对大家有所启发。","link":"/2017/02/07/fakedata/"},{"title":"不可不信缘－2015年度总结","text":"回顾2015，我一直试图告别土木工程，寻找属于我的江湖。 谈及我与土木的相遇，完全是因为高考成绩考砸了的缘故。但相遇即是一种缘分，因此我把这份缘分延续到了现在，可是这是一段不会有结果的旅程。回忆这八年，土木就像是我注定不爱的姑娘，一开始相识并不觉得什么，偶尔牵牵手还有点小愉快，可后来真的在一起了，才发觉一切都那么不自在，每个深夜满心的离开。其实我也不是现在才察觉，只是以前年轻，没有到迫在眉睫非彼即此的境地。现在工作都快整两年了，我也已经25了，我想这是最后的机会，去寻找自己的城。因此，这一年我做了两个大尝试。 一个是创业，一个是学编程。 2014年7月，戴瑞珠宝创业项目正式立项，前前后后累计7个人的小团队，当时干的也是风风火火轰轰烈烈。但后来起起伏伏，坎坷不断，2015年8月7日，我正式退出团队。一年有余的兼职创业，虽然没有期许的结果，却让我深刻的体会到，互联网才是年轻人龙争虎斗的天地，那里有梦想，有远方，有希望。而我所处的建筑行业，已然渐近荒原，很难说得上值得拼搏。我虽非大才，但也不甘沉沦，离开土木工程，跨入心向往之的互联网行业势在必行。只是在互联网行业，我去能干什么呢？八年的土木工程生涯，漫长的浸润，已经快把我体制化了。除了画CAD，似乎我什么都不会。隔行如隔山，此时我方体会至深，我该怎么办呢？2015年6月10日，我打开刚刚入手不久的Macbook，在知乎上搜索，“如何入门iOS编程？”，按照排名最高的答案，下载了Ray Wenderlich经典入门教程iOS Apprentice 1－ bull’s eye，再根据教程里的介绍，下载了Xcode，然后新建了我人生的第一个iOS 项目，从此开始了我的iOS探索旅程。回想起来，人生如梦，一切都是缘分。那时我买MacBook，只是因为七岁有余的Lenovo ideapad年迈力衰，行动迟缓，想换个MacBook，换个电脑，换个系统，换个体验，哪知它在我最迷茫的时候映入眼帘，哪知它在我最彷徨的时候，适时出现，指明路的方向，不可不信缘。接下来自然是我羞于提起却十分拿手的刻苦努力，四个月后，我基本入门。整个编程之路，风光旖旎，我很enjoy。也才发现，学习一个完全摸不着头脑的新事物，是多么的惊心动魄，趣味盎然。 《lost》电视剧有一句台词，我印象十分深刻，“Everybody is born with a destiny”。每个人生来都注定了自己的宿命，难道不是吗？总有一件事你最擅长，最热爱，最能让你疯狂。我想编程和做产品，就是我的宿命。在你最在意的事情上，倾注100%的努力。 在这次转变中，没能够尽力为公司付出，拿了钱，却不好好尽责，甚是惭愧，所以对2015年的省院一所，我真诚的说一句，“抱歉”。也希望，2016年，我能早日离开。","link":"/2016/01/10/believeInGod/"},{"title":"commit和branch理解深入","text":"深入理解git中commit和branch，有助于在日常开发中，更好的运用git。 commit的本质初始化目录为便于讲解，先创建一个如下目录结构的BeiLiao（贝聊是我所在的公司）目录: 在命令行中输出文件的目录结构如下：~ qingmo$: tree.└── BeiLiao ├── Component │ └── App.js ├── index.html └── index.js如果以竖向文件层级树的样式看是这样的（深色表示文件目录，浅色表示文件），其中App.js、index.html和index.js都填充了相应的内容。 初始化git并提交第一个commit先初始化git，然后添加所有文件到git的暂存区，成功后提交一个commit，最后log一下版本历史记录：~ qingmo$: cd ~/../BeiLiao(切换到BeiLiao这个文件目录)~ qingmo$: git init~ qingmo$: git add .~ qingmo$: git commit -m “init project”~ qingmo$: git logcommit 5bb33508dd4f00dd4d63c6e28546e044ebb51ac0Author: qingmo &lt;qingmo@163.com&gt;Date: Sun Mar 26 15:18:01 2017 +0800 init project 完成上述我们开发中的日常操作后，git便开始成功追踪BeiLiao整个文件夹，很炫很酷，但问题是git到底是如何做到的，而我们日常开发熟悉不能再熟悉的commit的本质又是什么？ 其实当我们运行git commit -m “init project”命令时，git主要进行了三个操作。 为每一个文件生成一个快照每一个文件其实是真的数据，所以git会把整个文件内容转成二进制，然后经过压缩直接存在键值对数据库中，对应的键值就是文件中的内容再附加一些头信息的40位校验和sha-1。既然是真数据，所以文件快照的类型为blob类型（binary large object）即大型二进制对象类型， 为每一个文件夹生成一个快照文件夹并不是直接的文字数据，其主要记录的是文件夹的结构和每个文件或者文件夹所对应的快照键值，所以文件夹的快照内容主要是其包含的所有文件和文件夹的键值信息总和，附加一些头信息，如文件名，文件夹名。对应快照键值为快照内容的40位校验和sha-1。既然不是直接数据，数据类型与文件快照必然不同，文件夹快照对应的类型为tree类型。 生成一个项目快照也即生成一个commit，项目快照的内容主要包含四部分信息，根项目目录的快照、提交人信息、项目快照说明（即commit信息）和父项目快照。其中项目文件快照，只要根目录即BeiLiao的目录快照即可。项目快照commit的键值为项目快照内容的40位校验和sha-1。项目快照类型为commit类型。 git commit -m “init project”后，生成的object引用图表如下图（浅灰色的表示文件快照，为blob类型，深蓝色的表示文件夹快照，为tree类型，绿色的表示项目快照，为commit类型）： git中生成的所有object都存在.git/objects/文件夹内，每一个object保存时，取其40位校验和sha-1的前两位生成文件夹，后38位作为文件名，存储对应的数据。git commit -m “init project”后，git的.git/objects/文件夹内容如下图： 下图把.git/objects/中的每一个object对应的内容文件一一标注了出来，可以很清晰的看到每一个数据object到底是什么。 添加文件并提交第二个commit在Component文件夹添加一个新文件Footer.js，形成新的文件目录结构：~ qingmo$: tree.└── BeiLiao ├── Component │ ├── App.js │ └── Footer.js ├── index.html └── index.js然后添加一个新的提交~ qingmo$: git add .~ qingmo$: git commit -m “add footer”此时生成的object引用图表如下图： 可以看出，新添加的Footer.js生成了一个快照efdfb8，其所在的文件夹Component也因新添加的文件而产生了内容的变化，因此也生成了新的快照017bde，同样的根文件夹BeiLiao也生成了新的快照3d7c8c。最终的形成新的commitd34903指向最新的根文件BeiLiao的快照3d7c8c。 需要注意的是，只有变化的文件或文件夹才会形成新的快照，没有变化的文件不会形成新的快照。 一个branch是什么branch的信息记录在.git/refs/heads/目录下， 用文本编辑器打开 master文件，内容是：d34903acaba24d2eccc8f5227ca61e6b0f7bd783这是最新commit的键值，所以branch仅仅是指向一个commit的指针而已，指向一个commit，而一个commit同时指向其父commit，如此循环最终形成了一个branch。 HEAD指针那git是怎么知道项目在master分支上呢？HEAD指针。git有一个独立的HEAD指针，记录项目现在所在的位置，比如现在我们在master分支上，查看.git/HEAD文件，内容为：ref: refs/heads/master此时HEAD指针指向master，所以项目在master分支上。 当我们创建一个新的分支test时，git会在.git/refs/heads/目录下生成一个文件test，并将其指向当前HEAD所指向的分支master所指向的提交d34903（有点绕），并把HEAD指向新的分支test。 当我们在新的分支生成新的commit时，git会将HEAD所指向的分支test所指向的commit作为新commit的父commit，然后将HEAD所指向的分支test移动指向新的提交。 可以看出HEAD指针在整个git中的重要性，没有HEAD，就不知道当前项目的位置，就不会生成新的提交，也不会创建新的分支（除非用git的底层命令）。 总结git中每一个文件会生成一个blob类型的object记录这个文件的状态，每一个文件夹都会生成一个tree类型的object就录这个文件夹的状态，一个项目会生成一个指向根目录tree object的commit类型object作为项目的快照。 branch其实只是指向一个commit的指针而已，HEAD记录了当先项目的位置。","link":"/2017/03/22/gitcommit/"},{"title":"《创建型设计模式》之iOS系统框架实践","text":"为了API的易用性、易维护性和健壮性，苹果工程师在iOS系统框架中其实运用了不少经典设计模式，而这些实践也正是因为良好的封装性，开发中我们虽日日相对，却也难以察觉它的存在。相对于其他生搬硬造隔靴搔痒的例子，这些我们熟悉的不能再熟悉的API方是学习设计模式的最佳案例。因此本系列拟以iOS系统框架中相关设计模式的实践为起点，探讨研究23种经典设计模式。 本文先讲述《创建型设计模式》(Creational Patterns)。 创建型设计模式是在创建一个类时用到的设计模式，总共有5种，其中工厂方法模式还可以根据实现的不同，分出简单工厂模式和工厂方法模式。 简单工厂模式(Factory Method)iOS系统Foundation框架中的NSNumber所应用的就是简单工厂模式。简单工厂模式主要解决不同情况下，需要创建不同子类，而这些子类又需要转化为公共父类让外界去使用的问题，因为这样对外接口只有一个，实际行为却因子类的具体实现而不同。拿NSNumber来说，传入Int、Float、Double、Char和UnsignedChar等具体number，NSNumber返回的是对应的NSNumber子类，而我们使用时只知NSNumber，不知具体的子类。 import UIKitlet boolValue: Bool = truelet doubleValue: Double = 1.0let boolN = NSNumber(value: boolValue)let doubleN = NSNumber(value: doubleValue)print(type(of:boolN))print(type(of:doubleN)) 输出结果为__NSCFBoolean__NSCFNumber 如果用简单工厂方法实现NSNumber（为了不与系统的NSNumber混淆，本文自己定义的NSNumber均去掉NS前缀，改为Number），代码大致如下：// 抽象产品protocol Number { func doubleValue() -&gt; Double func boolValue() -&gt; Bool}// 生产工厂class NumberFactory { func createNumber(value: Bool) -&gt; Number { return __NSCFBoolean(value: value) } func createNumber(value: Double) -&gt; Number { return __CFNumber(value: value) }}// 具体的产品Aprivate class __CFBoolean: Number { let bool: Bool init(value: Bool) { bool = value } func doubleValue() -&gt; Double { return bool ? 1 : 0 } func boolValue() -&gt; Bool { return bool }}// 具体的产品Bprivate class __CFNumber: Number { let double: Double init(value: Double) { double = value } func doubleValue() -&gt; Double { return double } func boolValue() -&gt; Bool { return double != 0 }}其中Number是抽象协议，负责定义行为，而__CFNumber和__CFBoolean是实现了Number抽象协议的私有实体类，NumberFactory则是一个创建Number的工厂。 具体使用时，先创建工厂，然后根据需要创建具体的实体类：// 先创建工厂let factory = NumberFactory()// 然后根据需要创建实体类let boolN = factory.createNumber(value: false)let doubleN = factory.createNumber(value: 2.0)而由于Objective-C的初始化方法中可以直接返回子类型，因此不必创建一个单独的工厂类NumberFactory，直接将相应的工厂方法逻辑封装在NSNumber的init方法中即可：@implementation NSNumber- (NSNumber *)initWithBool:(BOOL)value { return [[__NSCFBoolean alloc] initWithBool:value];}- (NSNumber *)initWithDouble:(double)value { return [[__NSCFNumber alloc] initWithDouble:value];}@end而在Swift中不可能从init初始化方法中返回一个子类。(Swift的init方法除了return nil外不能有返回值) 工厂方法模式(Factory Method)简单工厂模式中，工厂只有一个实体类NumberFactory，每当添加新的产品（即新实现Number协议的子类），都需要去修改这个工厂。比如上文新添加一个针对Float实现Number协议的__CFFloat（系统中的NSNumber并没有实体子类__NSCFFloat，而是所有的数字类型都封装为__NSCFNumber），// 新添加的具体的产品Cprivate class __CFFloat: Number { let float: Float init(value: Float) { float = value } func doubleValue() -&gt; Double { return Double(float) } func boolValue() -&gt; Bool { return float != 0 }}那么NumberFactory也需要改动：// 生产工厂class NumberFactory { func createNumber(value: Bool) -&gt; Number { return __NSCFBoolean(value: value) } func createNumber(value: Double) -&gt; Number { return __CFNumber(value: value) } // 新添加的工厂方法 func createNumber(value: Float) -&gt; Number { return __CFFloat(value: value) }}为解决这个弊端，可以将工厂NumberFactory也抽象一层，定义为一个协议：// 抽象工厂protocol NumberFactory { func createNumber(value: Any) -&gt; Number}然后针对不同的Number实体子类，都定义相应的工厂NumberFactory子类即可：// Bool 专用的工厂类class BoolNumberFactory: NumberFactory { func createNumber(value: Any) -&gt; Number { guard let value = value as? Bool else { fatalError(\"value must be a bool\") } return __CFBoolean(value) }}// Double 专用的工厂类class DoubleNumberFactory: NumberFactory { func createNumber(value: Any) -&gt; Number { guard let value = value as? Double else { fatalError(\"value must be a double\") } return __CFNumber(value) }}具体使用中，先创建工厂，然后直接根据相应的工厂创建相应的Number：// 先创建工厂let boolFactory = BoolNumberFactory()let doubleFactory = DoubleNumberFactory()// 然后直接根据相应的工厂创建相应的Numberlet boolN = boolFactory.createNumber(value: false)let doubleN = doubleFactory.createNumber(value: 2.0)如果想新添加一个针对Float实现Number协议的__CFFloat，添加完成后，直接再添加一个对应的NumberFactory子类即可。// Float 专用的工厂类class FloatNumberFactory: NumberFactory { func createNumber(value: Any) -&gt; Number { guard let value = value as? Float else { fatalError(\"value must be a float\") } return __CFFloat(value) }}这就是工厂方法模式与简单工厂模式的区别，即工厂方法模式不但抽象了产品，而且抽象了工厂。 抽象工厂模式(Abstract Factory)工厂方法模式抽象了工厂，但只负责生产一种产品。抽象工厂模式与工厂方法模式一般无二，都是抽象了工厂和产品，只是抽象工厂模式中的抽象工厂会负责生产一种以上相关联、会一起使用的产品。还是以Number的抽象工厂NumberFactory举例。Foundation中类似NSNumber类簇的，还有NSArray:import UIKitlet array0 = NSArray(array: [])let array1 = NSArray(arrayLiteral: 1, 2)let array2 = NSArray(arrayLiteral: 1)print(type(of:array0))print(type(of:array1))print(type(of:array2))打印结果如下：__NSArray0__NSArrayI__NSSingleObjectArrayI定义NSArray的抽象协议并实现两个私有类__CArray0和__CArrayI，为不与系统中的NSArray和Array混淆，这里取CArray：protocol CArray { var count: Int { get } // 其他公共接口}private class __CArray0: CArray { var count = 0 // 其他公共接口实现}private class __CArrayI: CArray { var count = 0 // 其他公共接口实现}定义Number和CArray的抽象工厂协议NumberAndArrayFactory：protocol NumberAndArrayFactory { // 用来生产Number的工厂方法 func createNumber(value: Any) -&gt; Number // 用来生产CArray的工厂方法 func createCArray() -&gt; CArray}定义抽象工厂NumberAndArrayFactory的具体实现类BoolNumberAndArray0Factory:class BoolNumberAndArray0Factory: NumberAndArrayFactory { func createNumber(value: Any) -&gt; Number { guard let value = value as? Bool else { fatalError(\"value must be a bool\") } return __CFBoolean(value) } func createCArray() -&gt; CArray { return __CArray0() }}具体使用时，先创建抽象工厂NumberAndArrayFactory的具体实现类，然后在调用这个实现类上的工厂方法，创建相应的产品Number或者CArray：// 创建抽象工厂`NumberAndArrayFactory`的具体实现类let boolNumberAndArray0Factory = BoolNumberAndArray0Factory()// 调用工厂方法，创建相应的产品let boolNumber = boolNumberAndArray0Factory.createNumber(true)let 0CArray = boolNumberAndArray0Factory.createCArray()需要注意的是，这里为了说明抽象工厂模式，抽象工厂NumberAndArrayFactory所创建的Number和CArray没有任何关联，在实际项目中，同一抽象工厂所创建的产品是关联的，一般是一起结合使用，如果不关联，也不必用抽象工厂模式。 建造者模式（builder）建造者模式是用来隔离复杂对象的配置过程，将复杂对象的配置过程单独封装成一个builder对象，完成配置后，再获取配置完成的实例对象。 cocoa中使用建造者模式的类是NSDateComponents,import Foundationvar builder = NSDateComponents()builder.hour = 10builder.day = 6builder.month = 9builder.year = 1940builder.calendar = Calendar(identifier: .gregorian)var date = builder.dateprint(date!)输出结果为：1940-09-06 01:00:00 +0000NSDateComponents相当于日期的一个builder，NSDateComponents用来配置日期的各个部分，配置完成后，最终获取对应的Date日期。NSDateComponents的实现大致如下（为避免与系统中的NSDateComponents和DateComponents混淆，这里取DateBuilder）：class DateBuilder { var hour = 0 var day = 0 var month = 0 var year = 1970 var calendar = Calendar(identifier: .gregorian) var date: Date { // 根据date components计算日期，比较复杂，这里省略了计算过程 let calculatedDate = ... return calculatedDate } }但这使用上不能链式调用，很不方便，加上各个属性的设置方法，返回自己本身，可以实现链式调用：class DateBuilder { var hour = 0 var day = 0 var month = 0 var year = 1970 var calendar = Calendar(identifier: .gregorian) var date: Date { // 根据DateComponents计算日期，比较复杂，这里省略了计算过程 let calculatedDate = ... return calculatedDate } func hour(_ hour: Int) -&gt; DateBuilder { self.hour = hour return self } func day(_ day: Int) -&gt; DateBuilder { self.day = day return self } func month(_ month: Int) -&gt; DateBuilder { self.month = month return self } func year(_ year: Int) -&gt; DateBuilder { self.year = year return self } func calendar(_ calendar: Calendar) -&gt; DateBuilder { self.calendar = calendar return self }}使用时很方便：let date = DateBuilder().hour(1).day(2).month(12).year(2017).date 原型模式(Prototype)原型模式其实就是一个类能够通过自身copy，创建一个内容一模一样的新实例，这在iOS的系统框架Foundation中挺常见的，NSString、NSArray、NSDictionary和NSParagraphStyle的 copy、mutableCopy方法都能复制一个新的实例，从而免去了从零创建一个复杂类的麻烦。如NSParagraphStyle，当获取到一个paragraphStyle之后，突然又想在其基础上改动同时又不想直接改变原来NSParagraphStyle，最方便的不过copy一份原来的，然后在改动。let paragraphStyle = NSParagraphStyle.defaultlet mutablePara = paragraphStyle.mutableCopy() as! NSMutableParagraphStylemutablePara.lineSpacing = 10mutablePara.paragraphSpacing = 5如果想实现原型模式，在swift中直接实现NSCopying和NSMutableCopying协议即可。 单例模式(Singleton)单例模式即一个类至始至终只有一个实例（单例类是可以新创建实例的，但一般都会用公共的那个单例实例），常用于Manager上。单例在iOS系统中十分常用，如NSParagraphStyle.default 、 UIScreen.main 、 UIApplication.shared 、 UserDefaults.standard和FileManager.default等都是单例。let paragraphStyle = NSParagraphStyle.defaultlet screen = UIScreen.mainlet application = UIApplication.sharedlet userDefault = UserDefaults.standardlet fileManager = FileManager.default在swift中实现一个单例模式，也是非常简单的。class Manager { // 单例 static let shared = Manager() // 私有化后，这个对象只会有单例这一个实例 private init() { }}上述单例，初始化方法私有化了，因此在整个APP的生命周期中，将只有一个此类的实例，即单例。但有时，单利只是给一个默认配置而已，如果想自定义，可以完全重新初始化一个新的实例，如class ParagraphStyle { // 单例 static let default = ParagraphStyle() // 没有私有化，这个对象如果有需要可以创建单例以外的新的实例 init() { }} 总结创建型设计模式在iOS系统中的运用相当广泛，而我们开发中只要有一定的抽象，基本都会用到，尤其是简单工厂模式和工厂模式、单例模式，希望本文的讲解能让大家能真正理解这些开发模式，并在开发中顺利应用。 参考文章： Class Clusters 从NSArray看类簇 创建者模式－建造者模式(The Builder Pattern) 简单工厂模式(Simple Factory Pattern) 工厂方法模式(Factory Method Pattern) 抽象工厂模式(Abstract Factory) Swift中编写单例的正确方式","link":"/2017/03/11/creationalDesignPattern/"},{"title":"再见土木，hello world!","text":"从07年至今，算下来，我学土木也近十年。十年的浸润，不敢说造诣很深，但至少基础坚实，如果继续努力，相信结果不坏。如今突然离开，跨越至IT，十年的成长轮为羁绊，又回到起点的感觉，惶惶不安。 其实我并不是一个爱冒险的人，而且结构工程师、设计院，也是不少人梦寐以求的，在社会上颇受尊重，但自己身在其中，总有太多的烦躁相伴，痛苦相随。痛苦是很有价值的感受，因为无论你怎么偏离你命中注定的航线，它都会一点一点地将你校正到正确的方向，即使你不勇敢，它也会让你变得义无反顾。当初进省院一所时，我曾经说自己很适合这个行业，我相信不少人也一直坚定的这么认为，连我自己也不例外，因为我比较宅、爱钻研、情商低、不善言辞。但理所当然的事却没有发生，机械式的画图、挥之不去的强条、冷酷无情的修改，让我精疲力尽、无言以对。仔细回想，除了偶有的绘图技巧提高带来的成就感外，竟难找到一丝专业的乐趣。即使建筑落成，行走其中，内心也并不以是自己设计的而汹涌澎湃。除了令人垂涎的稳定，自己实在找不到继续前行的理由。这才发现，原来自己本就不属于这里！ 那去哪里呢？天地苍茫，何处是归途？十年的浸润，学好了土木工程，却也荒废了其他所有武功。如今离开了土木，自己似乎啥都不会。一下子又站在十字路口，不知向左向右，甚至连左右在哪里都不知！但也不是完全不知道，二十年来的生活感悟，总有一些细微的暗示。那我到底喜欢什么呢？高晓松说，当你不知道自己喜欢什么的时候，就反着想，排除那些自己不喜欢的。第一，我瞧不起当官的，肮脏，第二，我瞧不起一味耍嘴皮子的管理者，基本是混饭，第三，我希望自己的工作是国际化的，能参与到这个世界中，而不是仅仅中国或者广东一隅之地，第四，我喜欢写点东西，第五，我并不一个爱出点子的人，但希望能去实践自己本来就不多的的想法，第五，我不喜欢一眼看到头的生活，要有希望，第六，我梦想能改变世界一点点，第七，希望自由一些，自己能说走就走。其实这么看来，自己就是很希望过上罗振宇所说的，优盘式的插拔生活，自由技术工，虽然没有任何保障，但感觉很精彩。这种类型的工作其实挺多，视频编辑，摄影，写程序，做产品，UI设计，金融理财等，而自己是个理科生，天赋更多的在逻辑上，刚好自己曾经学过Java等，因此最终选择了程序员。 于是乎，我拿起当时刚买的Macbook，在知乎上搜索如何入门iOS编程，按照最热的答案，下载Xcode和RayWenderlich的iOS Apprentice 1: Bull’s Eye，然后手起健落，输入print(“hello world!”)，从此在编程这条道路上无法自拔。我这时才发现，编程几乎复合自己所有的需求和价值判断，确实很适合自己。另外，浸润土木这十年，其实自己无意间也给自己留了编程这条人生蹊径。大学期间，在别人恣意蓝胖子等魔兽英雄的时候，我修了数学二学位，疯狂学了英语，艰难自学了Java。当时看起来傻傻的，现在却逆转了人生。我又想起乔布斯在斯坦福毕业典礼上说的，人的一生就是各个点连成的线，你做的每一件事情都是这条线上的点，你永远不知道下一个点在哪里，但过去的点连成的线把你指引到某个地方。过去的这些毫无意义的点，或许就暗示我现在的命运。 离开土木，进入编程后，曾经的乌云一下子消散了，整个世界天朗气清，惠风和畅，鸟语花香，姹紫嫣红，一切一下子都变的欣欣然，飘飘然。每天都很开心，此时才真的庆幸当初的勇敢，也感悟到，人生其实真的没什么好犹豫不决的，只要是真想，只要一直努力，结果总不会太坏。 离开土木离开一所，其实还是有些不舍。一所融洽的氛围像极了研究生阶段的大学，大家早上匆匆来到教研室，说说笑笑，吵吵闹闹，中午围着方桌一起吃饭，有忧国忧民操碎了总理心的，有无底线段子漫天飞舞的，有自黑不霞的，也有沉默无语的。闲暇时，还偶尔去美丽如画的流花湖公园漫不经心的散步闲谈。如果不是甲方马不停蹄的催促，一切竟像宁静的午后茶话时光。只是这些终究抵不过内心的执着！ 再见土木，hello world！走到现在，有太多的遗憾。如果时光倒转，真希望自己能早些醒悟，迷途，不必执着的太远！当然庆幸的是这一路，有不少有才华有意思的人相伴。我一直想影响一些人，因此我读了一些书，想了一些事，但最具说服力和感染力的还是自己脚下的路，希望您能由此有所感悟！","link":"/2016/07/11/goodbye/"},{"title":"如何让pod update快到飞起？","text":"想成为一个好的程序员，翻墙是必备技能，查个资料、搜个问题啥的，百度实在是渣（不是黑百度），可以说编程，不翻墙没法活。 至于如何翻墙，方法很多，有自己买VPN的，有公司自己配的，也有走代理的。个人最喜欢shadowsocks，可惜现在已经找不到正规的下载地址了，但只要用心找找，总还是有好人分享的。如果您用的是mac，实在下载不到，可以在评论中把邮箱留下，我发给你。 有了翻墙软件，固然神清气爽，但pod update等终端命令发起的网络请求却不能走代理，几乎停滞的下载速度让人窒息，有时候项目稍微大一点，一个pod update命令能跑一上午，这还编什么程序，如果pod update能快到飞起，那是怎样令人神往的感觉？ 办法总是有的，这就是这个时代最迷人的地方。 前提再说一遍前提，必须得先能翻墙，并且翻墙后的网速得比较快。准备起飞了 安装proxychains 先安装proxychains 打开Mac的terminal，并输入一下命令： brew install proxychains-ng 再配置proxychains 编辑配置文件 vim /usr/local/etc/proxychains.conf，在末尾注释掉原来的代理并添加 socks5 127.0.0.1 1080 关闭SIP（System Integrity Protection ） 重启Mac 在OS X启动之前，按住command-R，直到出现苹果logo和进度条。系统进入recovery mode 选择uitilities -&gt; terminal 输入 csrutil enable --without debug 终端中应该会出现设置成功的提示信息 重启Mac 测试准备起飞 重启Mac后，打开terminal，并输入 proxychains4 curl google.com 如果显示 [proxychains] config file found: /usr/local/Cellar/proxychains-ng/4.11/etc/proxychains.conf[proxychains] preloading /usr/local/Cellar/proxychains-ng/4.11/lib/libproxychains4.dylib[proxychains] DLL init: proxychains-ng 4.11[proxychains] Strict chain ... 127.0.0.1:1080 ... 220.255.2.153:80 ... OK&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;&lt;TITLE&gt;301 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;301 Moved&lt;/H1&gt;The document has moved&lt;A HREF=&quot;http://www.google.com/&quot;&gt;here&lt;/A&gt;.&lt;/BODY&gt;&lt;/HTML&gt; 证明代理成功，如果显示失败，请Google原因。 成功后，如果想pod update，在终端中输入， proxychains4 pod update 请静静的享受飞起的速度！","link":"/2016/08/04/podupdate/"},{"title":"翻转二叉树之Swift实践","text":"Google: 90% of our engineers use the software you wrote(HomeBrew), but you can’t invert a binary tree on a whiteboard so fuck off. HomeBrew作者，天才程序员Max Howell兴致盎然地去Google面试（估计是刚好路过），结果却因不会在白板上翻转二叉树被Google粗鲁地拒绝了，舆论甚是哗然，其中缘由知乎上也讨论的热火朝天。谁料，始作俑者翻转二叉树这道题目，一时也热地不要不要的。作为程序员小白的我，从未翻过二叉树。最近闲来无事，闲暇之余，想及至此，就顺手用Swift翻转了二叉树。 如果您对二叉树的概念不甚清晰，可以先到维基百科上（不推荐百度百科，因为要养成良好的搜索习惯）再温习温习二叉树相关知识。 二叉树定义先定义一个二叉树类Tree，主要定义树的三个必要属性，关键值key，左子树leftTree和右子树rightTree。//define Tree classclass Tree { var key: Int var leftTree: Tree? var rightTree: Tree? init(key: Int) { self.key = key } } 递归翻转用递归的方式翻转二叉树，主要分为两步：//invert binary tree using recursivefunc invertBinaryTreeWithRecursive(root: Tree) { //1 let tempT = root.leftTree root.leftTree = root.rightTree root.rightTree = tempT //2 if let leftT = root.leftTree { invertBinaryTreeWithRecursive(leftT) } if let rightT = root.rightTree { invertBinaryTreeWithRecursive(rightT) }}第1步：翻转本树的左子树和右子树，需要借助一个零时变量tempT；第2步：判断左右树是否存在，如存在，则递归调用进行翻转。 递归翻转二叉树每个节点只访问1次，在每个节点上的耗时是常数，因此总耗时Θ(n)，n是树的节点树。 非递归翻转其实也可以不用递归翻转二叉树，分为3步：//invert binary tree without using recursivefunc invertBinaryTreeWithoutRecursive(root: Tree) { //1 var arr = [Tree]() arr.append(root) //2 while !arr.isEmpty { let node = arr.removeFirst() let tempT = node.leftTree node.leftTree = node.rightTree node.rightTree = tempT //3 if let leftT = node.leftTree { arr.append(leftT) } if let rightT = node.rightTree { arr.append(rightT) } }}第1步：初始化一个数组，用来存储尚未翻转的树，第一个尚未翻转的树即是根树；第2步：判断是否仍有树未翻转，如果有，从数组中取出第一个树，并将它从数组中删除，然后对这个树翻转左子树和右子树，需要借助一个零时变量tempT；第3步：判断被翻的树左右子树是否存在，如存在，将它依次存储在数组的最后面。 这种翻转二叉树的方式是从左到右翻完同一层的树节点，再从左到右翻下一层的树节点，直至翻完，其耗时也是Θ(n)。 遍历二叉树为了遍历二叉树，输出有树形状的结果，先定义一个辅助函数，计算树的高度. 计算树的高度//calculate the height of a tree using recursivefunc heightOfTree(root: Tree) -&gt; Int { //1 var leftTreeHeight = 0 var rightTreeHeight = 0 //2 if let leftT = root.leftTree { leftTreeHeight = 1 + heightOfTree(leftT) } if let rightT = root.rightTree { rightTreeHeight = 1 + heightOfTree(rightT) } //3 return max(leftTreeHeight, rightTreeHeight)} 计算树的高度也必须用到递归。第1步：初始化两个高度变量，分别代表左右子树高度，缺省值为0，即左右子树均为nil时的值；第2步：判断左右子树是否存在，如存在递归求左右子树的高度；第3步：返回左右子树高度的最大值，这一步是递归终止条件，是整个递归的精髓。 因为遍历了所有树节点，因此总耗时Θ(n)。 遍历为输出的结果具有树的形状，树的遍历输出要费点脑筋，分4步：//print out binary tree in the shape of tree when the key is less than 10func tranverseTree(root: Tree) { //1 let height = heightOfTree(root) var trees = [(tree: root, number: 1, height: height, depth: 0, placeHolderTree: false)] let placeHolderTree = Tree(key: 0) //2 func appendTree(tree: Tree?, node: (tree: Tree, number: Int, height: Int, depth: Int, placeHolderTree: Bool)) { let number: Int if let last = trees.last { number = last.height == node.height - 1 ? last.number + 1 : 1 } else { number = 1 } if let t = tree { trees.append((tree: t, number: number, height: node.height - 1, depth: node.depth + 1, placeHolderTree: false)) } else { trees.append((tree: placeHolderTree, number: number, height: node.height - 1, depth: node.depth + 1, placeHolderTree: true)) } } //3 while trees[0].height &gt;= 0 { let node = trees.removeFirst() let space: Int if node.number == 1 { space = Int(pow(2.0, Double(node.height))) } else { space = Int(pow(2.0, Double(node.height + 1))) } for _ in 1..&lt;space { print(\" \", terminator: \"\") } if node.placeHolderTree { print(\" \", terminator: \"\") } else { print(node.tree.key, terminator: \"\") } if node.number == Int(pow(2.0, Double(node.depth))) { print(\"\") } //4 appendTree(node.tree.leftTree, node: node) appendTree(node.tree.rightTree, node: node) } }整个遍历的思路与invertBinaryTreeWithoutRecursive:完全一致。第1步：初始化一个数组，存储元组类型(tree: Tree, number: Int, height: Int, depth: Int, placeHolderTree: Bool)；这个元组中tree表示一个树节点；number表示这个树节点在其所在层的位置，第一个number为1，第二个number为2，依次类推；height表示这个树节点的高度；depth表示这个树节点的深度；placeHolderTree表示这个树节点是否为占位树。为便于后续遍历，当树为非完全二叉树时，空缺的树节点全部用占位树填补，因此才有placeHolderTree元组元素，以标示占位树； 第2步：这是一个utility函数，在第4步时调用； 第3步：判断树是否到底，当没到底时，从数组中取出并删除第一个节点，然后计算并打印这个节点相应的空格数，然后打印节点key值，如果这个节点是同一层级最后一个节点，打印换行； 第4步：将这个节点的左右子树连同相应信息存储到数组中，这时调用了第2步中的utility函数appendTree:node:，appendTree:node:中对传入的树节点进行了判断，当为空时，自动填补占位树。 此函数遍历了所有树节点，因此总耗时Θ(n)。 测试生成二叉树，并进行测试：let tree = Tree(key: 1)tree.leftTree = Tree(key: 2)tree.rightTree = Tree(key: 3)tree.leftTree?.leftTree = Tree(key: 4)tree.leftTree?.leftTree?.leftTree = Tree(key: 6)tree.rightTree?.leftTree = Tree(key: 7)tree.leftTree?.leftTree?.rightTree = Tree(key: 5)print(\"------tree before inverting-------\")tranverseTree(tree)print(\"------tree inverted-------\")invertBinaryTreeWithRecursive(tree)tranverseTree(tree) 输出结果为：------tree before inverting------- 1 2 3 4 7 6 5 ------tree inverted------- 1 3 2 7 4 5 6 感悟纵观上述二叉树翻转过程，用的知识较难的无非就是递归，而递归作为编程的精髓，学习稍微深入，就难以避免，而Max Howell竟然不会，或许是久疏战阵，髀肉横生吧。也说明互联网知识繁多，常常难以多头兼顾，记住所有知识，我们应保持一颗积极学习的心态。","link":"/2016/03/27/reverseBinaryTree/"},{"title":"iOS两个客户端代码复用小技巧","text":"一般一个App只有一个客户端，因此也只有一份代码仓库，也就无所谓复用不复用。但两个客户端也不是没有，美团、饿了么等就分商家版和买家版，贝聊App也分为老师版和家长版两个客户端。有两个客户端代码复用就在所难免，比如基本的工具类，比如一些共用的业务。本文就以贝聊App为例，分享当有两个客户端时代码复用的小技巧。 repository仓库划分贝聊APP远程仓库划分为三个，一个家长端repository，一个老师端repository，一个两端共用的BLKit repository。 家长端的本地repository包含远程的家长端repository和两端共用的Kit repository。老师端的本地repository包含远程的老师端repository和两端共用的Kit repository。 用submodule管理共用模块BLKit一个端要包括两个repository，而且这两个repository还是相互依赖，怎么管理也是个问题。 git中submodule允许在一个主git中存在另外独立的子git，而且主git还能记录每一次commit中子git所在的commit，这是完美的仓库独立却又相互依赖的管理方案。 如下图： 通过cocoapods将BLKit引入项目虽然利用submodule可以很好的管理共用模块BLKit，但又如何将BLKit引入到project中呢？ 有两个方案， 直接加入主project可以通过add files to project，选择所有BLKit中的文件，添加到主project中。但这样做的隐患非常大： BLKit不独立BLKit是两端共用模块，因此BLKit只能使用BLKit内部的类，否则在另外一个端中是不能编译的。如果BLKit的文件被添加到主project中，很容易在BLKit的某个文件中初始化了主项目中的一个类，导致BLKit很难维护。 BLKit不能更新BLKit直接添加到主project中，如果一端有添加新文件，另外一端拉取下来后，还得手动通过add files to project将新添加的文件添加到主project中。如果每次只是添加一个文件还好，如果文件一多，想死的心都有。 通过cocoapods管理将BLKit像其他第三方依赖库一样，用cocoapods管理，只不过pods的文件源连接到本地的BLKit仓库而已。 首先在主项目中的submodule文件夹中，创建一个BLKit.podspec，然后按照podspec的规则，填写podsspec，然后在主项目中的Podfile，像添加普通pod一样，将BLKit添加到Podfile中，pod 'BLKit', :path =&gt; &quot;./BLKit/&quot;然后pod update即可，这时BLKit就像普通的第三方依赖库一样，出现在pods中: 用cocoapods管理好处是很明显的： BLKit完全独立BLKit由于在pods中，不能引用主项目中的类，完全独立，不会出现一端更新，另外一端不能使用的情况。 BLKit自动更新由于BLKit其实就是个pods而已，如果远程BLKit有更新，拉取到本地后，运行pod update --no-repo-update 即可。千万加上--no-repo-update这个选项，因为pod update很慢很慢很慢。（当然如果利用proxychain，pod update也很快，但实在没有必要为乐更新BLKit更新整个pod） 如何在BLKit中引用主项目业务模块两端共用的模块，一般都是基础功能模块，比如网络模块，数据缓存模块、图片下载模块、视频发送模块等，都完全独立，与主项目没有耦合。但有时业务模块也有共用，比如聊天模块、大图浏览模块等。业务模块与主项目很难完全没有耦合，比如大图浏览模块长按时的操作逻辑，比如聊天模块长按消息的跳转逻辑，况且有时，有些业务模块被抽象成共用的，有些业务模块却没有，共用模块却要引用主项目中没有抽象成共用的业务模块。比如贝聊App中的聊天模块是共用的聊天模块，但大图浏览模块却不是共用的，因为历史原因，家长端和老师端各有各的实现，但点击聊天页面的图片消息，会进入大图浏览模块。 那如何在BLKit中引用主项目中业务模块？ 以BLKit中的聊天模块为例，// 这个类在Pods中class ChatViewController: UIViewController { let chatID: String init(chatID: String) { self.chatID = chatID } // 其他业务代码 // Table Cell delegate func didTapImageIn(cell: UITableViewCell) { // 进入大图浏览模块 let allImages: [URL] = [self getAllMessageImages] }}聊天的Cell的代理为ChatViewController，当点击到图片Cell，会调用代理方法 didTapImageIn(cell:)。ChatViewController实现了这个代理方法，获取到所有图片的URL后，需要调用主项目中的大图浏览模块。但Pods中是不可能直接调用主项目中的方法的。所以需要一个桥梁。 定义一个信使协议可以定义一个信使协议，然后在主项目中初始化ChatViewController时，传入具体实现这个信使协议的类。// pods中// 信使协议protocol ChatMessenger { func openPhotoViewer(with photoes: [URL], in context: UIViewController)}然后主项目中创建一个类实现ChatMessenger协议，// 主项目中class ChatMessengerConcrete: ChatMessenger { func openPhotoViewer(with photoes: [URL], in context: UIViewController) { // 具体调用主项目中的大图浏览模块 }}修改ChatViewController接受一个ChatMessenger作为初始化参数，然后在点击图片的cell代理方法中调用ChatMessenger的大图浏览：// 这个类在Pods中class ChatViewController: UIViewController { let chatMessenger: ChatMessenger let chatID: String // 初始化方法中传入ChatMessenger init(chatMessenger: ChatMessenger, chatID: String) { self.chatMessenger = chatMessenger self.chatID = chatID } // 其他业务代码 // Table Cell delegate func didTapImageIn(cell: UITableViewCell) { let allImages: [URL] = [self getAllMessageImages] // 进入大图浏览模块 chatMessenger.openPhotoViewer(with: allImages, in: self) }}然后在主项目中的聊天入口，初始化ChatViewController，并传入实现ChatMessenger协议的ChatMessengerConcrete:// 比如消息列表页class ChatListViewController: UIViewController { func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) { // 获取对应indexPath的聊天ID let chatID = \"\" let chatVC = ChatViewController(chatMessenger: ChatMessengerConcrete(), chatID: ) navigationController?.pushViewController(chatVC, animated: true) }} 使用协议扩展虽然可以在主项目中聊天的入口处，传入ChatMessenger的实体类，达到在Pods中调用主项目业务模块，但如果聊天入口也都抽象到Pods中的BLKit中，那在Pods中是无法初始化一个主项目中的ChatMessenger实体类的。 这时可以利用Swift中的protocol extension，在主项目中给Pods中的ChatMessenger协议一个默认实现。// 主项目中extension ChatMessenger { func openPhotoViewer(with photoes: [URL], in context: UIViewController) { // 具体调用主项目中的大图浏览模块 }}再让Pods中聊天页类ChatViewController遵循ChatMessenger协议，然后需要主项目中的业务直接调用对应的方法即可。 // 这个类在Pods中class ChatViewController: UIViewController, ChatMessenger { let chatID: String // 初始化方法中传入ChatMessenger init(chatID: String) { self.chatID = chatID } // 其他业务代码 // Table Cell delegate func didTapImageIn(cell: UITableViewCell) { let allImages: [URL] = [self getAllMessageImages] // 进入大图浏览模块 openPhotoViewer(with: allImages, in: self) }} 协议扩展是实现Pods中调用主项目业务模块的最好方式。 总结当有两个客户端时， 1）建立一个或多个两端共用的repository，管理两端相同的业务模块和功能模块2）利用submodule在主项目中管理两端共用的repository3）利用私有pods将submodule中的共用代码引入project中4）利用协议扩展轻松实现在pods中调用主项目中的业务模块","link":"/2017/04/08/sharecode/"},{"title":"排序算法之Swift实践","text":"当我们站在历史的今天，往过去回顾，总会发现一些在当下习以为常的观念，惊讶在过去竟然没人意识到，比如生产力决定生产关系，比如自由平等，这就是所谓的进步。我生于上世纪九十年代初，年纪尚轻，这些观念的巨大变革，我大多从书上学来的，如果要找一些真正有切身体会的，我想就是当下有点烂大街的用户体验。与过去单纯讲究功能性的时代相比，用户体验绝对是完全颠覆的，它完全变换了产品的核心，给人一种醍醐灌顶的顿悟感，想及此，还是要感谢乔布斯和他的苹果。 算法与用户体验看似没有关系，其实算法是上佳用户体验的基础，因为没有高效的算法，机子会卡。我至今仍是编程小白，为加深对算法的理解，本文尝试用Swift实现大部分常用的排序算法。 经典排序算法插入排序//不改变输入数组的状态，返回排序完成的降序数组func insertionSort(var arr:[Int]) -&gt; [Int] { for var i = 1; i &lt; arr.count; i++ { let key = arr[i] var j = i - 1 while j &gt;= 0 &amp;&amp; arr[j] &gt; key { arr[j+1] = arr[j] j-- } arr[j+1] = key } return arr} 插入排序为原址排序，总耗时与输入的分布有关，当输入为倒序时，为最坏输入分布，排序时间为Θ(n^2)，当输入为正序时，为最佳输入分布，排序时间为Θ(n)，其中n是输入规模。 冒泡排序func bubleSort(var arr: [Int]) -&gt; [Int] { for var i = arr.count - 1; i &gt; 0; i-- { for var j = 0; j &lt; i; j++ { if arr[j] &gt; arr[j + 1] { let temp = arr[j] arr[j] = arr[j + 1] arr[j + 1] = temp } } } return arr} 冒泡排序为原址排序，总耗时与输入的分布无关，耗时O(n^2) 高阶排序算法归并排序//不改变输入数组的状态，返回排序完成的降序数组func mergeSort(var arr: [Int]) -&gt; [Int] { func internalMergeSort(p: Int, _ r: Int) { if p &lt; r { let q = Int( floor(Double(p + r) / 2.0) ) internalMergeSort(p, q) internalMergeSort(q + 1, r) merge(p, q, r) } } func merge(p: Int, _ q: Int, _ r: Int ) { var leftA = [Int]() var rightA = [Int]() for var i = p; i &lt;= q; i++ { leftA.append(arr[i]) } for var i = q + 1; i &lt;= r; i++ { rightA.append(arr[i]) } for var k = p; k &lt;= r ; k++ { if !leftA.isEmpty &amp;&amp; !rightA.isEmpty &amp;&amp; leftA[0] &lt;= rightA[0] { arr[k] = leftA.removeFirst() } else if leftA.isEmpty &amp;&amp; !rightA.isEmpty{ arr[k] = rightA.removeFirst() } else if !leftA.isEmpty &amp;&amp; rightA.isEmpty { arr[k] = leftA.removeFirst() } else { arr[k] = rightA.removeFirst() } } } internalMergeSort(0, arr.count - 1) return arr} 归并算法的总耗时与输入分布无关，耗时Θ(nlgn)，但不是原址排序，空间复杂度略高，占用较多内存。 堆排序//代码中用到了floor:函数，因此必须导入UIKit模块import UIKit//不改变输入数组的状态，返回排序完成的降序数组func heapSort(var arr: [Int]) -&gt; [Int] { func left(i: Int) -&gt; Int { return 2 * i + 1 } func right(i: Int) -&gt; Int { return 2 * i + 2 } func maxHeapify(i: Int, heapSize: Int) { let l = left(i) let r = right(i) var largest = i if l &lt; heapSize &amp;&amp; arr[largest] &lt; arr[l] { largest = l } if r &lt; heapSize &amp;&amp; arr[largest] &lt; arr[r] { largest = r } if largest != i { let temp = arr[i] arr[i] = arr[largest] arr[largest] = temp maxHeapify(largest, heapSize: heapSize) } } func buildMaxHeap() { for var i = Int(floor(Double(arr.count) / 2.0 - 1.0)); i &gt;= 0; i-- { maxHeapify(i, heapSize: arr.count) } } func internalHeapSort() { for var i = arr.count - 1; i &gt; 0; i-- { let temp = arr[i] arr[i] = arr[0] arr[0] = temp maxHeapify(0, heapSize: i) } } buildMaxHeap() internalHeapSort() return arr} 堆排序算法耗时依赖输入的分布，其总耗时O(nlgn)。 快速排序//经典快速排序，为原址排序func quickSort(var arr: [Int]) -&gt; [Int] { func partition(p: Int, _ r: Int) -&gt; Int { var i = p - 1 let key = arr[r] for var j = p; j &lt; r; j++ { if arr[j] &lt; key { i = i + 1 let temp = arr[j] arr[j] = arr[i] arr[i] = temp } } arr[r] = arr[i + 1] arr[i + 1] = key return i + 1 } func internalQuickSort(p: Int, _ r: Int) { if p &lt; r { let q = partition(p, r) internalQuickSort(p, q - 1) internalQuickSort(q + 1, r) } } internalQuickSort(0, arr.count - 1) return arr} 快速排序为原址排序，耗时依赖于输入分布，最坏耗时Θ(n^2)，最好耗时Θ(nlgn)，而平均耗时非常接近最好耗时情形，因此快速排序在实际中有广泛的应用。 上述排序算法没有利用Array的高阶函数filter:，如果用filter:函数重写，代码更加简洁://利用高阶函数filter:实现快速排序func quickSort(var arr: [Int]) -&gt; [Int] { if arr.count &gt; 0 { let q = arr.removeFirst() let leftA = arr.filter{$0 &lt;= q} let rightA = arr.filter{$0 &gt; q} return quickSort(leftA) + [q] + quickSort(rightA) } return arr }利用高阶函数filter:实现快速排序，虽然使代码开起来非常简洁，但却牺牲了原址排序的空间简洁性，大幅增大了内存的消耗。 验证验证如下：let arr = [2, 1, 6, 4, 3]print(\"-------- 输入数组 --------\")print(arr)print(\"-------- 插入排序结果 --------\")print(insertionSort(arr))print(\"-------- 冒泡排序结果 --------\")print(bubleSort(arr))print(\"-------- 归并排序结果 --------\")print(mergeSort(arr))print(\"-------- 堆排序结果 --------\")print(heapSort(arr))print(\"-------- 快速排序结果 --------\")print(quickSort(arr))输出结果为:-------- 输入数组 --------[2, 1, 6, 4, 3]-------- 插入排序结果 --------[1, 2, 3, 4, 6]-------- 冒泡排序结果 --------[1, 2, 3, 4, 6]-------- 归并排序结果 --------[1, 2, 3, 4, 6]-------- 堆排序结果 --------[1, 2, 3, 4, 6]-------- 快速排序结果 --------[1, 2, 3, 4, 6] 总结每一种算法都代表着一种不同的思路，甚至是一种思想，如归并排序代表着分治的思想，堆排序代表着堆的思想。思想的变化，看待问题角度的转换，总是给人无数的乐趣。也说明要想有大的突破，人不能太狭隘。","link":"/2016/03/29/sortAlgorithm/"},{"title":"《结构型设计模式》之iOS系统框架实践","text":"结构型设计模式是从程序的结构上解决模块之间的耦合问题，主要包括适配器模式、桥接模式、组合模式、装饰器模式、外观模式、享元模式和代理模式等7种经典设计模式，在iOS系统框架中组合模式、装饰器模式和享元模式是有经典实现的，而适配器模式、桥接模式、外观模式和代理模式iOS系统框架中的实现并不明显，但在第三方框架或者贝聊（我所在的公司）的App是有用到的，为便于讲解，本文会挑选最恰当的例子。 本文是设计模式之iOS系统框架实践系列中的第二篇（总共三篇），如果您对《创建型设计模式》感兴趣，建议看看我的前一篇文章《创建型设计模式》之iOS系统框架实践。 适配器模式（Adapter）适配器模式是将一种接口，转换成另外一种接口，一般被适配的类的功能与外界所希望的一致，只是接口与外界所希望的不同，所以需要适配接口。一般需要新旧接口的转换时用到。不少资料上讲iOS中的delegate委托就是一种适配器模式，个人觉得太牵强。虽然将一个现有的类，扩展遵循指定delegate的协议，实现了接口的改变，但功能完全是新添加的，何来接口转换只说？（原来苹果官方资料说protocol就是适配器模式，也是醉了） 由于暂未发现iOS系统框架中特别典型的适配器模式，本文就以贝聊App中的IM（instant message即时通讯）项目为例。 贝聊IM用的是阿里百川云望（下文简称云望）服务器，UI自己实现。对于每一条消息，云望都有自己的消息类型YWMessage（云望SDK中定义的一个协议），大体协议结构如下：import UIKit// 消息体实体类class YWMessageBody { }// 消息协议protocol YWMessage { var messageId: String { get } var fromPersonId: String { get } var toPersonId: String { get } var createDate: TimeInterval { get } var conversationId: String { get } var messageBody: YWMessageBody { get }}为解除第三方SDK与贝聊App内部聊天UI过渡耦合，需要将云望消息类型转换成贝聊自己的消息类型，也是个协议，贝聊消息协议定义如下：protocol MessageBody { }protocol Message { var messageID: String { get } var senderID: String { get } var receiverID: String { get } var createTimeInterval: TimeInterval { get } var conversationID: String { get } var messageBody: MessageBody { get } }云望消息类型YWMessage和贝聊消息类型Message接口功能基本一致，只是接口定义不一致，这就需要接口的适配。虽然云望SDK消息类型公开的接口是个YWMessage协议，但当有消息发送过来时，所收到的是一个实现了YWMessage协议的具体私有类，YWMessageConcrete，为实现接口转换，定义一个做消息转换的适配器消息类MessageAdaperForYWMessage：class MessageAdaperForYWMessage: Message { let ywMessage: YWMessage init(ywMessage: YWMessage) { self.ywMessage = ywMessage } var messageID: String { return ywMessage.messageId } var senderID: String { return ywMessage.fromPersonId } var receiverID: String { return ywMessage.toPersonId } var createTimeInterval: TimeInterval { return ywMessage.createDate } var conversationID: String { return ywMessage.conversationId } var messageBody: MessageBody { return ywMessage.messageBody }}extension YWMessageBody: MessageBody { } 组合模式（Composite）组合模式就是将对象组合成树形结构，以表示“部分-整体”的层次结构，而且单个对象和组合对象的接口一致，如果从整个树形结构中截取任何一部分，client不知是单个对象，还是组合对象。对应的类图如下： 容器类（Composite）和叶子类（Leaf)其实都是实现Component接口的子类，client在使用时不做区分，都当作Component使用。容器类可以添加容器或者叶子做子类，而叶子类不能添加任何子类。所形成的树形结构如下： 在UIKit中，我们熟悉的不能再熟悉的UIView和CALayer是经典的组合模式，并且UIView和CALayer并没有区分容器类和叶子类，而是统一只有一个单一容器类UIView和CALayer。其实这样使用起来更加亲民，不用区分是容器还是叶子。 UIView的实现起来是相当简单的（为不与系统UIView混淆，这里取View），如下：import UIKitclass View: Equatable { var subviews: [View] = [] var superView: View? func addSubview(subview: View) { subviews.append(subview) } func removeSubview(subview: View) { if let index = subviews.index(of: subview) { subviews.remove(at: index) } } func draw(_ rect: CGRect) { // 具体的绘制图形的代码 }}// Array.index(of:)必须遵循Equatable协议func == (lhs: View, rhs: View) -&gt; Bool { return lhs === rhs}具体使用时，先创建各个View，然后根据需要添加层级关系如下：let view1 = View()let view2 = View()let view3 = View()let view4 = View()let view5 = View()let view6 = View()let view7 = View()let view8 = View()view1.addSubview(subview: view2)view1.addSubview(subview: view3)view3.addSubview(subview: view4)view3.addSubview(subview: view5)view4.addSubview(subview: view6)view6.addSubview(subview: view7)view6.addSubview(subview: view8)形成的树形结构如下图： 这也是我们常说的UIView层级。 桥接模式（Bridge）桥接模式是把抽象部分和实现部分分离，使它们都可以独立的变化。 由于暂未发现iOS系统框架中特别典型的适配器模式，而在贝聊APP和第三方库我也没遇到过，本文就以Design-Patterns-In-Swift的例子为例：protocol Switch { var appliance: Appliance {get set} func turnOn()}protocol Appliance { func run()}class RemoteControl: Switch { var appliance: Appliance func turnOn() { self.appliance.run() } init(appliance: Appliance) { self.appliance = appliance }}class TV: Appliance { func run() { print(\"tv turned on\"); }}class VacuumCleaner: Appliance { func run() { print(\"vacuum cleaner turned on\") }}用法：var tvRemoteControl = RemoteControl(appliance: TV())tvRemoteControl.turnOn()var fancyVacuumCleanerRemoteControl = RemoteControl(appliance: VacuumCleaner())fancyVacuumCleanerRemoteControl.turnOn() 装饰器模式（Decorator）装饰器模式，也叫装饰者模式，能够实现动态的为对象添加功能，是从一个对象外部来给对象添加功能。装饰器模式就是基于对象组合的方式，可以很灵活的给对象添加所需要的功能。 根据具体实现方式的不同，分类装饰器和对象装饰器两种模式。 类装饰器模式，就是直接扩展现有的类，不新增一个类。swift中的extension特性对应的就是类装饰器模式。比如想给UIImage增加一个ratio的属性，直接extenstion UIImage类即可：import UIKitextension UIImage { var ratio: CGFloat { return size.height / size.width }}使用起来也很方便：let image = UIImage(named: \"sampleImage\")!print(image.ratio)对象装饰器模式，是新增一个装饰类，然后持有一个被装饰类，通过给装饰类添加功能，增加被装饰类的功能。在UIKit中，UIView与CALayer，UIViewController与UIView是典型的对象装饰器模式。 UIView装饰了CALayer，给CALayer添加了事件响应等全新的功能。UIViewController装饰了UIView，给UIView添加了viewDidLoad、viewDidAppear 、viewWillAppear、viewWillDisappear 、viewDidDisappear、viewDidLayoutSubviews等生命周期，UIViewController带UIView来到了全新的世界的同时，也把自己演变成身份十分独特的控制器类，进而成就了经典的MVC设计模式。 比如UIView装饰CALayer的简易实现（为不与系统UIView混淆，这里取View）如下：class View: UIResponder, CALayerDelegate { // 被装饰的layer lazy var layer: CALayer = { let layer = CALayer() // 注意layer的delegate是View本身 layer.delegate = self return layer }() // 需要将CALayer功能暴露给外界的接口 var frame: CGRect { set { layer.frame = newValue } get { return layer.frame } } // 给CALayer新增加的事件响应功能 override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) { } override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) { } override func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) { } override func touchesCancelled(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) { }}可以定义一些接口，将被装饰的类的功能暴露给外界。 外观模式（Facade）外观模式为子系统中的一组接口提供一个统一的更高层次的接口，使得子系统更加容易使用，说白了就是为了简化复杂的接口。 iOS系统框架中特别典型的外观模式暂未发现，其实我们常用的SDWebImage和YYWebImage在API设计上都采用了典型的外观模式。 例如想从一个URL加载图片：import UIKitimport SDWebImagelet imageView = UIImageView()imageView.sd_setImage(with: URL(string: \"http://www.domain.com/path/to/image.jpg\"), placeholderImage: UIImage(named: \"placeholder.png\"))看似把URL直接传入UIImageView的sd_setImage(with:placeholderImage:)方法这么简单，其实从服务器加载图片其实是一个比较复杂的过程，主要涉及三个模块： 缓存管理模块，查看有没有对应的缓存，以及缓存一张图片到磁盘或者内存 图片下载模块 网络请求模块，图片下载模块又依赖网络请求模块 import UIKitextension UIImageView { func setImage(with url: URL, placeHolder: UIImage) { let imageCacher = ImageCacher.shared let imageDownloader = ImageDownloader.shared if let cachedImage = imageCacher.cachedImageFor(url: url) { image = cachedImage return } image = placeholder imageDownloader.downloadImageFrom(url: url) { (image, error) in self.image = image if let image = image { imageCacher.cache(image: image, url: url) } } }} 其中依赖了缓存管理模块和图片下载模块：// 图片下载模块class ImageDownloader { static let shared = ImageDownloader() func downloadImageFrom(url: URL, completionHandler:@escaping (UIImage?, Error?) -&gt; Void) { // 用到了网络下载模块 let downloadTask = URLSession.shared.dataTask(with: url, completionHandler: { (data, response, error) in DispatchQueue.main.async { if let imageData = data { let image = UIImage(data: imageData) completionHandler(image, nil) } else { completionHandler(nil, error) } } }) downloadTask.resume() }}// 图片缓存模块class ImageCacher { static let shared = ImageCacher() // 从缓存中取缓存的UIImage，没有就返回nil func cachedImageFor(url: URL) -&gt; UIImage? { return nil } // 缓存图片 func cache(image: UIImage, url: URL) { // 缓存逻辑 }}使用起来跟SDWebImage一般无二：let imageView = UIImageView()imageView.setImage(with: URL(string: \"http://www.domain.com/path/to/image.jpg\"), placeholder: UIImage(named: \"placeholder.png\")) 享元模式（Flyweight）享元模式就是实现类的复用，因为当相同的类创建很多，会消耗很大系统内存。在UIKit中，UITableViewCell和UICollectionViewCell的复用就是典型的享元模式，如果UITableViewCell和UICollectionViewCell不复用，每一个cell都需要创建新的实例，不但消耗内存，同时也消耗时间，进而导致卡顿掉帧。 我们在使用UITableViewCell时，一般分为四步： 定义一个自定义cell 创建tableview 注册cell 从cell池（由tableView维护）取cell import UIKit// 1. 定义一个自定义cellclass CustomCell: UITableViewCell { }// 2. 创建tableviewlet tableView = UITableView()// 3. 注册celltableView.register(CustomCell.self, forCellReuseIdentifier: String(describing: CustomCell.self))// 4. 从cell池取celllet cell = tableView.dequeueReusableCell(withIdentifier: String(describing: CustomCell.self)) UITableViewCell复用逻辑的简易实现（为不与系统UITableView混淆，这里取TableView），如下：class TableView: UIScrollView { // 注册的cell class var registerredCellClasses: [String: UIKit.UITableViewCell.Type] = [:] // cell池 var cellPool: [String: [UITableViewCell]] = [:] // 注册复用的cell func register(_ cellClass: UIKit.UITableViewCell.Type, forCellReuseIdentifier identifier: String) { registerredCellClasses[identifier] = cellClass } // 复用cell方法 func dequeueReusableCell(withIdentifier identifier: String) -&gt; UITableViewCell? { // 检查有没注册 guard let cellClass = registerredCellClasses[identifier] else { return nil } if var cells = cellPool[identifier], cells.count &gt; 0 { // 检查cell池中有没有可复用的cell let cell = cells.removeFirst() cellPool[identifier] = cells // 准备复用 cell.prepareForReuse() return cell } else { // cell池没有可复用的cell，新创建一个 let cell = cellClass.init(style: .default, reuseIdentifier: identifier) return cell } } // 回收超出屏幕可视区域的cell， // TableView会监测正在显示cell的状态，当有cell完全进入不可视区域时，进行回收，逻辑比较复杂，这里不实现了 func collectCellInvisible(invisibleCell: UITableViewCell) { guard let identifier = invisibleCell.reuseIdentifier else { return } cellPool[identifier]?.append(invisibleCell) }}实现中， 需要记录注册cell和维护一个cell池。 当调用dequeueReusableCell(withIdentifier:)方法时，会先判断对应idenfitier有没注册的cell，确定有注册后，然后再看现有的cell池有没有可以复用的，有就复用，没有就直接创建一个新的cell。 TableView需要监测正在显示cell的状态，当有cell完全进入不可视区域时，进行回收。 代理模式（Proxy）代理模式是为其他对象提供一种代理以控制这个对象的访问，解决直接访问某些对象时出现的问题。 Foundation中的NSProxy采用的就是代理模式，但我们日常开发并不常用，本文就以Design-Patterns-In-Swift的例子为例：import UIKit// 专门负责开门的操作人员，不负责身份校验protocol DoorOperator { func open() -&gt; String}// 中南海开门操作人员class SeaPalaceDoorOperater : DoorOperator { func open() -&gt; String { return \"中南海欢迎您！\" }}// 中南海开门操作人员的代理，除了开门职责外，还负责校验身份class SeaPalaceDoorOperaterProxy : DoorOperator { private var doorOperator: SeaPalaceDoorOperater! func authenticate(password: String) -&gt; Bool { guard password == \"pass\" else { return false } doorOperator = SeaPalaceDoorOperater() return true } func open() -&gt; String { guard doorOperator != nil else { return \"对不起，您没有开门权限\" } return doorOperator.open() }}其中开门的操作人员DoorOperator只有开门这一单一职责，但开门是需要校验的，所以需要一个DoorOperator的代理，让其承担一部分校验的职责，具体开门的还是由被代理的DoorOperator来。这其实跟装饰者模式有点像，只是代理模式更关注对被代理类的控制，就像SeaPalaceDoorOperaterProxy主要控制外界对被其代理对象SeaPalaceDoorOperater的访问。 具体用法如下：let seaPalaceDoorOperater = SeaPalaceDoorOperaterProxy()seaPalaceDoorOperater.open()seaPalaceDoorOperater.authenticate(password: \"pass\")seaPalaceDoorOperater.open() 总结在iOS系统框架中， UIView和CALayer是典型的组合模式。 swift中的extension是典型的类装饰器模式。 UIView与CALayer，UIViewController与UIView是典型的对象装饰器模式。 UITableViewCell与UICollectionViewCell的复用机制是典型的享元模式。 苹果官方资料说protocol是变相的适配器模式，我还能说什么。 在贝聊App的项目中，云望消息类型转换到贝聊消息类型是典型的适配器模式。 在第三方框架SDWebImage中，UIImageView的sd_setImage(with:placeholderImage:)等下载网络图片的便捷方法是典型的外观模式。 而桥接模式和代理模式，由于未找到合适的例子，采用了Design-Patterns-In-Swift中的例子。 参考文章 iOS Design Patterns Design-Patterns-In-Swift 源码分析之SDWebImage Cocoa Design Patterns","link":"/2017/03/18/structuralpattern/"},{"title":"这一年与下一年-2016年度总结正式版","text":"这一年每当总结过去一年的时候，总感觉时间匆匆，一转眼又是一夏，一转眼又过一秋，时间流逝不止，我们只能以成长搪塞逐渐衰老的年华。 我是6月20日来到贝聊的，处于程序员小白水平的我，当时只能勤奋的追赶，努力的做些小项目练手，同时也疯狂的补齐残缺的编程知识。半年以后到今天，积累起来，完成的项目大大小小，林林总总，也有一二。如网络日志feature、班级列表刷新、老师端班级语音播报、家长端老师端发现改版及再改版、老师端和家长端好习惯首页和详情页、弹窗基础框架、优惠券详情页和帖子详情红包页、一系列小的工具拓展、大图浏览、客服、专属客服、客服评价等等。我是一个不喜欢拖累大家的人，不愿意大家因为我的原因出现拖延，因此这些项目大部分如时的交付，而且作为初学者，写代码时如履薄冰战战兢兢的，千般思虑，万般测试，因此上线后的bug并不多见，整体还算优良。 其实回想起这段日子，我能分明的感受到自己对编程的认识是一个层次一个层次的成长，每做一个大的feature项目，基本就会遇到一个大的问题，然后就向前进一步。记得我正式做的第一个独立feature是语音播报，迅速的写完UI，连通API后，随便测试一下就上线了，当时心里极其地没底，强烈地感觉代码能跑起来是随机的，我思考了很久也没找到让我心安地路径，但这个问题却一致残留在脑海，直到做了几个大的项目后，我才找到答案，那就是充分地自测和正确的开发流程，但是能做到这些也是在我解决其他同样让人苦恼的事之后了。 之后便接到了发现改版的feature，这个feature对我而言，是较新较重的，时间又非常紧迫，要5天后交货，我压力山大，当时我连怎么写请求，怎么发请求，怎么写model，怎么合理分离vc的职责等都还不懂，收到设计后，便立即动起手来实现UI，想着不懂的边写边学，疯狂5天后，不懂的真的都依葫芦画瓢地大概懂了，但是却不出意料的没有跟上进度，但谁曾料第五天上午突然接到消息说项目取消了，劫后余生我仰天长笑，不过做项目中有一朵巨大的乌云让我很烦恼，即如何处理UI更新与数据更新的耦合逻辑，我翻看了其他员工的部分代码，数据的流动杂乱不堪，UI更新随意罗列，就像在悬崖边飙车，刀锋上跳舞，看的我心惊肉跳。在苦思无解之际，有一天突然听到子豪极其推崇react的单向数据流，我灵机一动，突然意识到每一个VC的数据都可以看成这个VC的状态，而UI只是状态的表现，更新UI应该在更新状态之后，而状态更新应该集中处理，几番思考后，我确定这是个不错的想法。 于是很快，发现改版又启动了，世事变幻真是让人来不及定睛一看，这次我推翻了以前的逻辑架构，开始试验局部单向数据流动的想法，把dataSource更名为stateSource（现在想想正确的叫法应该为stateStore），把stateSource中所有model名都更改为state（现在想想应该所有的model类都应该更名为state），每一个state的状态都有一个对应的修改方法，在修改后利用stateSource持有的vc直接更新UI，而如果某一状态需要更新，直接调用相应状态的更新方法即可。这样，整个数据流动和UI更新就极其的清晰。现在想想这其实就是MVVM的思想，只不过我这里没有UI和数据的自动绑定。但在应用中，发现页面的状态并不多，局部单向数据流的优势发挥的并不明显，所以在后面的业务开发中，我并没有刻意把model名改为state，只是劫取了核心思想。 所谓按下葫芦又起瓢。在发现再改版中， 紧迫的工期导致接口定义迟滞，接口上线更是在末日之时，为不延误开发，客户端只能先只做UI，然后等后端接口定义完成后创建model、request，完成数据的填充，最后再等待接口上线连调。然后UI调试需要各种边界数据，等到后端给数据，那都要上线了，黄花菜都凉了，于是做假数据避无可避，但如何高效的做假数据呢？这又是一条漫长的修行之路。我一开始是在需要数据的地方直接写死，但如果忘了，假数据就是真数据了，这无形中给自己的头上悬挂了一把利剑，而这在我们组就真实的发生过。于是我又借鉴子豪的写法，在假数据周围包上宏判断，这是安全不少，但一个一个的假数据散落四处，根本无法统一管理，不统一等于没有管理。在研究了一段时间单元测试后，我发现OHHTTPStub很适合做同一的假数据，写一个JSON文件，然后截取网络请求，返回这个本地JSON文件的数据，再生产model，填充UI呈现，近乎完美的流程让我非常满意，于是我开始推荐给同事，但用着用着问题又来了，这些本地JSON文件很容易一疏漏就真的上线了，一方面使安装包更大，一方面如果OHHTTPStub的代码忘了删除，整个线上请求就都被Stub了，这就是事故了。而且随着代码时长的累积，我渐渐发现UI调试时，频繁的改动假数据JSON文件，编译，然后查看效果，很耗时，很累，很烦，如果能修改一下数据，刷新一下效果就在眼前多好。于是我开始研究反向代理，本地搭建server，然后窃取网络请求返回我想要的数据。但这需要我懂web的一些知识，门槛有点高，而且说实话也太复杂了些。就在我危难烦闷之际，Charles的MapLocal出现在我的面前，我看到那一刻惊呼道，这他妈就是我想要的吗？简单，好用，还有throttle。从那时开始，我一直用Charles的MapLocal做各种假数据，对我的UI进行各种边界条件的测试，因此感觉自己对程序又多了一些掌控和熟悉。 用Charles做假数据的方案确实让我窃窃回味了一段时间，事实上，假数据的有效突破让我另一个心腹大患有了化解的微光。那就是紊乱的开发流程。从开发第一个项目到现在，项目的开发流程都是先写UI，然后再写Model，request连接数据。这中间扭曲的逻辑，让写代码的我感觉到先被一点点的撕裂，然后再一针一针的努力的缝合之前的伤痕。app本质难道不是数据流动产生的一系列奇妙的反应吗？数据流动才是根本，根本如果不存在，何来UI？我想编程世界最开始的开发方式本就是先数据后UI的数据驱动式开发，然而随着项目工期的紧闭，先UI后数据的UI驱动式开发渐成主流。如果前后端能完全脱离，完全独立，数据驱动式开发其实是水到渠成的事，必然的选择。恰好Charles在场，Charles高效自由的假数据使得移动端只依赖于后端的接口定义，而事实上，接口的定义是服从于设计的，我们完全可以对照着设计，自定义接口，只需要有个胶水层，能将我们自定义的接口与服务器端的接口对接起来即可，感谢ibireme，其写的YYModel就具有这样的胶水功能，只要前端和后端定义的接口逻辑上有严格的一一对应的关系，利用YYModel就可以将二者无缝的粘合起来，再结合Charles的假数据机制，数据驱动式开发可以说轻而易举。在随后的好习惯开发中，我迫不及待地尝试了这种开发模式，虽然开发速度因为个人开发经验不足并未快多少，但逻辑上顺畅如行云流水。直到现在，我一直都采用这种更贴近人类思维的开发模式，而且现在后端的接口早早就定义好了，无需再自己定义接口，就更省心了。 经过激烈的七八九十月后，腥风血雨的日子总算平静了下来，但iOS较高的崩溃率和一波一波的bug，无情否定了曾经的所有努力，特别是在android快速高质的高冷姿态下，一个个bug像是一把一把冷箭，把我们伤的体无完肤。怎么提高自己的代码质量减少开发时的bug？有一次回家的路上我偶然看到一片文章关于怎样提高自己的代码质量，文中有几个观点对我非常大的启发，“代码是写给别人看的”，“写代码是讲究流程的”。原来如此，流程，确实应该有个正确的开发流程。我觉得大家平时开发都略显随意，而机器并不喜欢随意，所以才会有很多意外的bug。结合那篇博客的思想和数据驱动式的开发思想，从拿到需求到最终上线我比较推崇以下开发流程：------&gt;拿到需求------&gt;深入了解需求的细枝末节，跳转，各种边界条件，各种状态（减少bug的关键）------&gt;思考业务的实现细节，与技术负责人探讨架构和技术难点------&gt;实现与后端数据无关的技术难点------&gt;后端完成接口定义后，与后端对接口，了解接口的完备性和合理性------&gt;model、网络请求、view controller搭建数据框架------&gt;用Charles做假到逼真的数据------&gt;写UI（有真实数据做支撑）------&gt;用Charles模拟各种边界数据，充分测试UI------&gt;交付测试------&gt;一对一code review------&gt;按code review结果优化代码结构其中第二条的边界条件分析和第九条的充分自测是减少bug的重中之重，前面是思考，后面是验证，而最终的一对一code review则是从别人的角度提高自己的代码质量，是自我提升和项目整体质量的重中之重。从我开始写代码到现在，或多或少基本遵循这个开发流程，写出的代码自己信得过，也获得了团队的肯定，也无形中考验了这个流程。 上述的局部单向数据流、Charles假数据、数据驱动式开发、开发流程等等是这半年我在编程认识上取得的进步，对别人来讲，可能都是显而易见的知识，但我是从零开始，每前进一步，都凝结了自己的思考和同事的无私帮助，并没有那么容易。自己的进步或多或少能带动整个团队的精神和气氛，我想这应该是我对团队和贝聊最大的进步。 最尴尬的莫过于整了两个重大的bug，但总体上在贝聊的这半年，我很满意，曾几何时，我还在广东省建筑设计研究院一所工作，不少个日以继夜，无数个通宵达旦，面对还算可观的成绩，扑面而来的却是无聊烦躁和对人生的迷惘，而如今同样的日以继夜，同样的通宵达旦，同样的还算硕果累累，心理感觉感到的是充实和安定。初次转行就能来到贝聊，不得不说感谢，事实上，贝聊是当时唯一一家愿意要我的公司，也是我面试过的公司中，唯一一个我想去的。曲折的过程和如今近乎完美的结局都出乎我的意料，或许是我多年沉淀的运气，或许是对方犀利的眼力，也或许是我不那么突出但还有一点点的才华，也或许仅仅是一个巧合。 放眼整个这一年，不能说成长，却发生了彻底的变化，2016年我从事业单位变到了私企，从建筑变到了IT，从对程序茫茫然变到了懂那么一点点的小程序员，从随波逐流变到了自己去选择道路。变化铸就了内心的强大，回忆期间坎坎坷坷的苦涩，现在都莞尔一笑。 下一年记得贝聊面试我的时候，杨敏说特招我这个初学者，希望能以我旺盛的学习热情，去带动整个组的氛围。惭愧的是，这一年做的并不出色，我本身起点很低，一直在追赶，而在追赶别人的时候，你再努力，别人也只是在为你鼓掌。只有眼看着曾经比自己落后N个等级的人全面超越了自己，自己才会感受到落后的压力，进而产生动力。所以下一年，我想 在技术深度上，全面提高一个层次，看更多的开源库，研究一些有深度的课题，了解更多编程思想，了解更多程序方面的理念。 在技术广度上，全面掌握React技术栈，伟大的想法都是相互借鉴的，我不可能狭隘于单一的iOS技术栈。 开始学编程到现在，我非常感念开源社区和那些无偿分享知识的博主，如果没有这些默默无闻的奉献，编程学习之路必然十分崎岖坎坷。我现在已经过了初学阶段，对编程也有一些自己的认识和看法，我觉得是时候去回馈编程这个温暖的大家庭了。 大约每半年做一个有一定质量的开源库。 大约每一个月写一篇有一定质量和观点的博客。 对于团队， 我会想一些办法，在下一年切切实实的和大家一起成长。第三方开源库学习，专题研究，分享等。 提高整个团队的代码质量。design review和merge request一对一的code review。 也想尝试做一下： 基础工具小组，促进多语言学习、多平台学习和深度学习，而不是仅仅拘泥于一个小的平台上，也促进大家的产品思维。 语言学习小组。我们虽然不是大公司，但真心希望能成立一个整体的技术学习小组，利用公司的已有资源整体提升公司的技术水平。这个很难，大公司都有自己的培训体系，但我们没有，属于真正的从零做起，紧迫性也不高，而且需要纯输出的付出，我想很难找到真正愿意一起行动的。 个人规划： 8月份前处理结婚事宜。虽然已经领证，但还未结婚！ 去日本旅游一次，度度蜜月，看看外面的世界。 开始自我管理。随着职责越来越重，自由就越来越少，自我管理也就更加重要。包括健康、时间、效率等。 作为技术工，朋友圈一向狭窄。今年我想多认识一些人，多听听别人的想法。 往往计划就是用来计划的，林林总总我竟写了十几条，希望明年不只是勉强的笑谈，去掩饰内心的愧疚！","link":"/2017/01/25/thisYearAndNextYear/"},{"title":"typealias理解小误区","text":"alias在英语中是别名之意，那typealias，顾名思义，是指类型的别名。Swift的官方文档中对typealias关键词的演示，也是以＝赋值的形式，给一个现有类型取一个恰当的别名，便于在上下文中使用： protocol Container { typealias ItemType //some other things …}struct IntStack: Container { typealias ItemType = Int //some other things …} 如果ItemType的类型不是已有类型，还需另外定义：struct SomeType { }struct SomeStack: Container { typealias ItemType = SomeType //some other things …} typealias的两种用法根据上述typealias关键词的演示可知，typealias的使用一般分为两步： 独立定义一个目标类型SomeType； 将目标类型SomeType以 =的形式赋值给typealias别名。 typealias的两步使用法，结构清晰，意义明了，但也略显啰嗦。如果目标类型SomeType比较轻，是一些简单的类型，则两步可以合为一步，直接在实现Container protocol的类型中，定义一个与别名同名的类型即可： struct SomeStack: Container { struct ItemType ｛ ｝ //some other things …} 这样代码是不是显的更加紧凑简洁？当然这只适合于typealias的目标类型量级比较轻，且只用于typealias所在类型内时的情形。当typealias的目标类型体型庞大，应用范围不限于typealias所在类型时，还是分开定义为佳。 总结typealias的两种用法表明，别名并不只是别名，它指代的是一个类型，这个类型的获得，既可以通过赋值，也可以自定义，也即千万不要把typealias局限于别名的意义。","link":"/2016/03/26/typealias/"},{"title":"青葱年华-2016年度总结随写版","text":"仔细端详着年初许下的誓言，孤零零的转行二字高悬，简单的有点简陋，隐藏了背后所有的心酸。 2015年下半年，我紧闭着双眼，静静凝视着自己的灵魂，发现多年浸润土木，灵魂却渐渐干瘪了，随处可见的疮痍，应该是多少次默默承受苦痛，留下的伤疤，慢慢溃烂。不转行不行了，多次探索寻觅，最终走上了编程这条又臭又烂的不归路。数不清多少个通宵达旦的刻苦修炼，也不知道多少个无休无止的知识学习，2015年初，终于许下来年开始找工作的誓言和宏远。2016年上半年，草草应付了绘图工作，我开始奔波各大招聘网站，每天早上固定投简历，不拒绝任何一个面试，哪怕公司再小。三月去了，四月走了，五月也只是简单打了个照面，我等的offer却不见，零星的面试，去了又回，失落的情绪，破碎的幻想，绝望从一点点逐渐累积到汹涌迷漫。绝望到头了，我就开始幻想，幻想着有一家大公司要我，然后我踏踏实实的跟着团队学习，一开始肯定做不了什么大的贡献，但因为自己的努力，渐渐的真的成为公司不可或缺的一名优秀程序员。。。幻想着，幻想着，连幻想都没了。都6月了，该投的已经投了，未见offer的一点踪迹，仅有的几个面试中，面试官还苦口婆心的劝我别转，有的还说想跟我对调。看来iOS容不下我这个大才，于是6月中旬，我又重新调整了方向，开始向数据挖掘进发，回家在iPad中下载了十几本书，又开始了无休无止不知疲倦的学习。但就在这时，佛祖观世音菩萨太上老君孔圣人关二爷耶稣基督穆罕默德真主显灵了，迄今为止面过我公司中最大的贝聊竟然发来了offer，我勒个天，命运这是几个意思，这么照顾我？这么折磨我？我卷起铺盖就去了！ 对于转行人，最难的就是有人愿意给机会，一旦有，他们一定能抓住，因为他们想的更明白，看的更透彻，没有其他人的游移不定和躁动不安，他们会十分努力！ 进入贝聊后的第一周是相当煎熬的，他们按照连自己也未想好的特殊培训计划开始培训我，第一天学习OC语言和代码规范，第二天用OC重写机试题，第三天熟悉公司的网络框架，第四天和第五天写一个记录网络请求和响应情况的日志feature。每一天我几乎都处于懵逼和奔溃的状态，我利用我所有知道的知识预想应该有的流程，然后一点点的试，一点点的向前推进，我党经常说摸着石头过河，可是那几天连石头都要自己预想，我真怕完不成任务，因为他们说对我的要求很高。在6月25日初步完成了网络日志的feature后，我长出了口气，最惊险的考验算是过了。我其实不愿意面对特别有风险的事，当避无可避时，我总想象如果一闭眼一睁眼，跳过最惊险的片段，直接来到故事的结尾多好，但现实是不可逃避的，我每次都是硬着头皮上。之后就渐渐熟悉了在公司业务，也熟悉了公司的一些人，算是稳定了下来。 离开省院一所，来到贝聊，感受非常明显的是大家之间的距离很远，朝夕相处的同事，大部分都形同陌路，不打招呼，也不说话，平时很少有业务往来，基本上永远没有认识的机会，而在省院，由于就那么几个人，朝夕相处，业务往来也密切，不是今天跟你配合，就是明天跟你配合，彼此之间分外的亲近，来到贝聊一时间很不适应。 我的这一年差不多就这么点事，总结起来是转行，上半年找工作，下半年好好工作。以前我觉得转行很难，到现在我才知道，其实只要努力，只要真的有热情，煎熬也就一年而已，所以又有什么可拍的呢？ 当然我能这么顺利的转行，很大程度上也是因为家人的支持，特别感谢老婆，没有她平日间的鼓励、支持和理解，接下来的人生故事不知道会怎样书写。也对这一年因为转行没有去参加好哥们李昕的婚礼，感到万分的抱歉，这都不知道怎么弥补。 最后，我觉得，拥抱变化，不丢掉理想，并敢于实现自己的理想，才是真正的青葱年华，那样当两眼昏沉之时，回忆当初才鲜明的感觉自己曾经存在过，而不是由着生活的惯性，一步一步的沉沦到生命的终点，仿佛一场梦！","link":"/2016/12/31/youth/"}],"tags":[{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"Swift","slug":"Swift","link":"/tags/Swift/"},{"name":"人文","slug":"人文","link":"/tags/%E4%BA%BA%E6%96%87/"},{"name":"swift","slug":"swift","link":"/tags/swift/"},{"name":"closure","slug":"closure","link":"/tags/closure/"},{"name":"并发","slug":"并发","link":"/tags/%E5%B9%B6%E5%8F%91/"},{"name":"Objective-C","slug":"Objective-C","link":"/tags/Objective-C/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"commit","slug":"commit","link":"/tags/commit/"},{"name":"design pattern","slug":"design-pattern","link":"/tags/design-pattern/"},{"name":"小技巧","slug":"小技巧","link":"/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"}],"categories":[]}